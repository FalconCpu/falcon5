/**
 * Generate the header for the assembly file
 */

fun genAssemblyHeader(sb: StringBuilder) {
    sb.append("# Generated by Falcon Compiler\n")
}

private fun InstrAlu.genAssembly() : String = when(op) {
    BinOp.ADD_I -> "add $dest, $src1, $src2"
    BinOp.SUB_I -> "sub $dest, $src1, $src2"
    BinOp.MUL_I -> "mul $dest, $src1, $src2"
    BinOp.DIV_I -> "divs $dest, $src1, $src2"
    BinOp.MOD_I -> "mods $dest, $src1, $src2"
    BinOp.AND_I -> "and $dest, $src1, $src2"
    BinOp.OR_I -> "or $dest, $src1, $src2"
    BinOp.XOR_I -> "xor $dest, $src1, $src2"
    BinOp.EQ_I -> "xor $dest, $src1, $src2\ncltu $dest, $dest, 1"
    BinOp.NE_I -> "xor $dest, $src1, $src2\ncltu $dest, 0, $dest"
    BinOp.LT_I -> "clt $dest, $src1, $src2"
    BinOp.GT_I -> "clt $dest, $src2, $src1"
    BinOp.LE_I -> "clt $dest, $src2, $src1\nxor $dest, $dest, 1"
    BinOp.GE_I -> "clt $dest, $src1, $src2\nxor $dest, $dest, 1"
    BinOp.LSL_I -> "lsl $dest, $src1, $src2"
    BinOp.LSR_I -> "lsr $dest, $src1, $src2"
    BinOp.ASR_I -> "asr $dest, $src1, $src2"
    BinOp.LTU_I -> "cltu $dest, $src1, $src2"
}

private fun InstrAluLit.genAssembly() : String = when(op) {
    BinOp.ADD_I -> "add $dest, $src, $lit"
    BinOp.SUB_I -> "sub $dest, $src, $lit"
    BinOp.MUL_I -> "mul $dest, $src, $lit"
    BinOp.DIV_I -> "divs $dest, $src, $lit"
    BinOp.MOD_I -> "mods $dest, $src, $lit"
    BinOp.AND_I -> "and $dest, $src, $lit"
    BinOp.OR_I ->  "or $dest, $src, $lit"
    BinOp.XOR_I -> "xor $dest, $src, $lit"
    BinOp.EQ_I -> "xor $dest, $src, $lit\ncltu $dest, $dest, 1"
    BinOp.NE_I -> "xor $dest, $src, $lit\ncltu $dest, 0, $dest"
    BinOp.LT_I -> "clt $dest, $src, $lit"
    BinOp.GT_I -> "clt $dest, $src, ${lit+1}\nxor $dest, $dest, 1"
    BinOp.LE_I -> "clt $dest, $src, ${lit+1}\n"
    BinOp.GE_I -> "clt $dest, $src, $lit\nxor $dest, $dest, 1"
    BinOp.LSL_I -> "lsl $dest, $src, $lit"
    BinOp.LSR_I -> "lsr $dest, $src, $lit"
    BinOp.ASR_I -> "asr $dest, $src, $lit"
    BinOp.LTU_I -> "cltu $dest, $src, $lit"
}

private fun InstrBranch.genAssembly() : String = when (op) {
    BinOp.EQ_I -> "beq $src1, $src2, .$label"
    BinOp.NE_I -> "bne $src1, $src2, .$label"
    BinOp.LT_I -> "blt $src1, $src2, .$label"
    BinOp.GT_I -> "blt $src2, $src1, .$label"
    BinOp.LE_I -> "bge $src2, $src1, .$label"
    BinOp.GE_I -> "bge $src1, $src2, .$label"
    else -> error("Not a valid branch operand")
}

fun loadOp(size:Int) = when(size) {
    1 -> "ldb"
    2 -> "ldh"
    4 -> "ldw"
    else -> error("Invalid size")
}

fun storeOp(size:Int) = when(size) {
    1 -> "stb"
    2 -> "sth"
    4 -> "stw"
    else -> error("Invalid size")
}

private fun Instr.genAssembly() = when(this) {
    is InstrAlu -> genAssembly()
    is InstrAluLit -> genAssembly()
    is InstrBranch -> genAssembly()
    is InstrCall -> "jsr /${func.name}"
    is InstrVCall -> "ldw R30, R1[-4]\nldw R30,R30[${func.virtualFunctionNumber*4+12}]\njsr R30[0]"
    is InstrIndCall -> "jsr $func[0]"
    is InstrEnd -> ""
    is InstrJump -> "jmp .$label"
    is InstrLabel -> ".$label:"
    is InstrMov -> "ld $dest, $src"
    is InstrNop -> "nop"
    is InstrStart -> ""
    is InstrMovLit -> "ld $dest, $lit"
    is InstrLea -> "ld $dest, $src"
    is InstrLoad -> "${loadOp(size)} $dest, $addr[$offset]"
    is InstrStore -> "${storeOp(size)} $src, $addr[$offset]"
    is InstrLoadField -> "${loadOp(size)} $dest, $addr[${offset.offset}]"
    is InstrStoreField -> "${storeOp(size)} $src, $addr[${offset.offset}]"
    is InstrIndex -> "idx$size $dest, $src, $bounds"
    is InstrNullCheck -> "tiz $src\n"
}

fun Function.genAssembly(sb:StringBuilder) {
    if (name=="<TopLevel>")
        sb.append("init:\n")
    else
        sb.append("/$name:\n")

    for(comment in regAllocComments)
        sb.append("# $comment\n")

    // setup stack frame
    val makesCalls = prog.any{it is InstrCall || it is InstrVCall || it is InstrIndCall}
    val stackSize = stackVarSize + (if (maxRegister>8) 4*(maxRegister-8) else 0) + (if (makesCalls) 4 else 0)
    if (stackSize!=0) {
        sb.append("sub SP, SP, $stackSize\n")
        for(r in 9..maxRegister)
            sb.append("stw R$r, SP[${stackVarSize + 4*(r-9)}]\n")
        if (makesCalls)
            sb.append("stw R30, SP[${stackSize-4}]\n")
    }

    for(instr in prog) {
        if (instr is InstrStart || instr is InstrEnd)
            continue
        sb.append(instr.genAssembly())
        sb.append("\n")
    }

    // teardown stack frame
    if (stackSize!=0) {
        for(r in 9..maxRegister)
            sb.append("ldw R$r, SP[${stackVarSize + 4*(r-9)}]\n")
        if (makesCalls)
            sb.append("ldw R30, SP[${stackSize-4}]\n")
        sb.append("add SP, SP, $stackSize\n")
    }
    sb.append("ret\n\n")
}

fun genAssembly() : String {
    val sb = StringBuilder()
    genAssemblyHeader(sb)

    for(func in allFunctions)
        func.genAssembly(sb)
    emitAllValues(sb)
    return sb.toString()
}