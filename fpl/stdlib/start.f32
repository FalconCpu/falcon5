# Constants
HWREGS_BASE = 0xE0000000
HWREGS_SEVEN_SEG = 0x00
HWREGS_LEDR = 0x04
HWREGS_UART_TX = 0x10
HWREGS_SIM_MODE = 0x44

SYSVARS_BASE = 0x100
SYSVARS_HEAP_PTR = 0x00
SYSVARS_HEAP_END = 0x04

# #######################################################################
#                          Entry point
# #######################################################################
start:
ld SP, 0x4000000
jsr initializeMem
jsr /topLevel
jsr /main()

# #######################################################################
#                          Exit
# #######################################################################
# On the simulator, we exit by doing a jump to address 0

ld $1, HWREGS_BASE           # Load base address of hardware registers
ldw $2, $1[HWREGS_SIM_MODE]  # Load simulator mode register
beq $2, 0, .on_hardware      # If in hardware mode then we have nowhere to return to

# On simulator, so do a jump to address 0 to stop the simulator
ld R30, 0
ret

.on_hardware:
# On hardware, So indicate complete by flashing the LEDs forever
stw $8, $1[HWREGS_SEVEN_SEG]  # Display the return code on the 7-segment display

ld $1, 0x1
.forever:
stw $1, $20[HWREGS_LEDR]  # Flash the LEDs to show we are here
ld $2, 3000000
.delay:
sub $2, 1
bne $2, 0, .delay
lsl $1, 1
lsr $2, $1, 12
or $1, $2
jmp .forever  # Loop forever


# #######################################################################
#                          Print Function
# #######################################################################
# $1 = string to print   (length prefix format)

/print(String):
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    ldw $2, $1[-4]             # Load length of string
    add $2, $1                 # Pointer to just past the end of string
    jmp .cond

.loop:
    ldb $3, $1[0]               # Load character from string
    stw $3, $7[HWREGS_UART_TX]  # Print the character
    add $1, 1                   # Increment string pointer
.cond:
    bne $1, $2, .loop           # Repeat until string pointer is at end
    ret


# ==========================================================
#                     printInt
# ==========================================================
# $1 = value to print

/print(Int):
    sub $31, 16                # Allocate 16 bytes of stack space
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    bge $1, 0, .positive       # If value is positive, skip
    ld  $2, '-'                # Print the '-' character
    stw $2, $7[HWREGS_UART_TX]
    sub $1, 0, $1              # Negate the value

.positive:
    ld $6, $31                 # $6 = pointer to work space

.loop:
    modu $2, $1, 10            # $2 = $1 % 10
    divu $1, $1, 10            # $1 = $1 / 10
    add $2, '0'                # Convert digit to ASCII
    stb $2, $6[0]              # Store digit in work space
    add $6, 1                  # Increment work space pointer
    bne $1, 0, .loop           # Repeat until $1 is 0

.print:
    sub $6, 1                   # Decrement work space pointer
    ldb $2, $6[0]               # Load digit from work space
    stw $2, $7[HWREGS_UART_TX] # Print the digit
    bne $6, $31, .print         # Repeat until work space pointer is at base

.end:
    add $31, 16
    ret

# ==========================================================
#                     printChar
# ==========================================================
# $1 = character to print

/print(Char):
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    stw $1, $7[HWREGS_UART_TX] # Print the character
    ret

# ==========================================================
#                     printBoolean
# ==========================================================
# $1 = value to print

/print(Bool):
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    beq $1, 0, .false          # If value is 0, print "false"
    ld $2, 't'                # Print the 't' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 'r'                # Print the 'r' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 'u'                # Print the 'u' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 'e'                # Print the 'e' character
    stw $2, $7[HWREGS_UART_TX]
    ret
.false:
    ld $2, 'f'                # Print the 'f' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 'a'                # Print the 'a' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 'l'                # Print the 'l' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 's'                # Print the 's' character
    stw $2, $7[HWREGS_UART_TX]
    ld $2, 'e'                # Print the 'e' character
    stw $2, $7[HWREGS_UART_TX]
    ret

# ==========================================================
#                     initializeMem
# ==========================================================
initializeMem:
ld $1, SYSVARS_BASE          # Load base address of system variables
ld $2, 0x1000                # Set Start of heap to address 4096 byte
stw $2, $1[SYSVARS_HEAP_PTR] # Store end of heap in system variables
ld $2, 0x3f00000             # Set end of heap to address 0x3f00000
stw $2, $1[SYSVARS_HEAP_END] # Store end of heap
ret

# ==========================================================
#                     malloc
# ==========================================================
# $1 = size in bytes to allocate
malloc:
ld $4, SYSVARS_BASE          # Load base address of system variables
ldw $2, $4[SYSVARS_HEAP_PTR] # Load current heap pointer
ldw $3, $4[SYSVARS_HEAP_END]  # Load end of heap

add $1,3                     # Round size up to multiple of 4 bytes
and $1, 0xFFFFFFFC
ld $8, $2                    # Save original heap pointer for return value
add $2, $1                   # Bump pointer
bge $2, $3, .outOfMemory     # Check if we have enough space
stw $2, $4[SYSVARS_HEAP_PTR] # Update heap pointer
ret

.outOfMemory:
ld $8, 0                     # Set return value to 0 (null pointer)
ret

# ==========================================================
#                     malloc Array
# ==========================================================
# $1 = number of elements
# $2 = size of each element in bytes
/mallocArray:
sub $sp, 8                # Allocate space on stack for two variables
stw $9, $sp[0]
stw $30, $sp[4]
ld $9, $1                 # Keep number of elements in $9
mul $1, $2                # Calculate total size in bytes
add $1, 4                 # Add space for header (length prefix)
jsr malloc                # Call malloc to allocate memory
beq $8, 0, .end           # Check if malloc failed
add $8, 4                 # Update pointer to point to first element
stw $9, $8[-4]            # Store number of elements at the start of
.end:
ldw $30, $sp[4]           # Teardown stack frame
ldw $9, $sp[0]
add $sp, 8              # Restore stack pointer
ret

# ==========================================================
#                     malloc Object
# ==========================================================
# $1 = class descriptor

/mallocObject:
sub $sp, 8                # Allocate space on stack for two variables
stw $9, $sp[0]
stw $30, $sp[4]
ld $9, $1                 # $9 = Class descriptor
ldw $1, $9[0]             # Load size of class from descriptor
add $1, 4                 # Add space for header (length prefix)
jsr malloc                # Call malloc to allocate memory
beq $8, 0, .end           # Check if malloc failed
add $8, 4                 # Update pointer to point to first field
stw $9, $8[-4]            # Store class descriptor at the start of object
.end:
ldw $30, $sp[4]           # Teardown stack frame
ldw $9, $sp[0]
add $sp, 8              # Restore stack pointer
ret




# ==========================================================
#                     bzero
# ==========================================================
# $1 = pointer to memory
# $2 = size in bytes to clear
/bzero:
beq $2, 0, .done         # If size is 0, nothing to do
add $4, $1, $2           # Calculate end pointer
or $3, $1, $4            # Check the start and end pointers are aligned
and $3, 3
bne $3, 0, .unaligned
.loop:
stw 0, $1[0]          # Store 0 at the current
add $1, 4
bne $1, $4, .loop      # Repeat until we reach the end
.done:
ret
.unaligned:
stb 0, $1[0]          # Store 0 at the current byte
add $1, 1
bne $1, $4, .unaligned # Repeat until we reach the end
ret


# ==========================================================
#                     strcmp
# ==========================================================
# Compare two strings lexicographically
# $1 = pointer to string 1
# $2 = pointer to string 2
# returns:
# $8 negative if string 1 < string 2, 0 if equal, positive if string 1 > string 2

/strcmp:
    ldw $3, $1[-4]       # get the length of string 1
    ldw $4, $2[-4]       # get the length of string 2

    ld $5, $3           # get the length of the shorter string
    blt $3, $4, .skip1
    ld $5, $4
.skip1:
    add $5, $5, $1       # point to end of shorter string
    jmp .check_end       # jump to compare point (in case both strings are empty)

.loop:
    ldb $8, $1[0]        # get a character from string 1
    ldb $6, $2[0]        # get a character from string 2
    sub $8, $6           # subtract the characters
    bne $8, 0, .done     # if they are not equal, we are done
    add $1, 1            # increment string 1 pointer
    add $2, 1            # increment string 2 pointer
.check_end:
    blt $1, $5, .loop    # if we have not reached the end of shorter string then loop

    sub $8, $3, $4       # set $8 indicate which string is longer
.done:
    ret


# ==========================================================
#                     strequal
# ==========================================================
# Compare two strings for equality
# $1 = pointer to string 1
# $2 = pointer to string 2
# returns:
# $8 = 1 if equal, 0 if not equal
#
# This makes use of the fact strings are word-aligned, and padded with 0 to a multiple of 4 bytes

/strequal:
    ldw $3, $1[-4]          # get the length of string 1
    ldw $4, $2[-4]          # get the length of string 2
    ld $8, 0               # set $8 to 0 - default return value
    bne $3, $4, .done      # if the lengths are not equal, we are done
    add $3, $1             # point to end of string 1  (Note since we know both strings are the same length,
                           # we don't need to calculate which is shorter
.loop:
    ldw $4, $1[0]          # get a word
    ldw $5, $2[0]          # get a word
    bne $4, $5, .done      # if the words are not equal, we are done
    add $1, 4              # increment string 1 pointer
    add $2, 4              # increment string 2 pointer
    blt $1, $3, .loop      # if we have not reached the end of the strings then loop
    ld $8, 1               # set $8 to 1 (true)
.done:
    ret

