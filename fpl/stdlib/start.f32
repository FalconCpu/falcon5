# Constants
HWREGS_BASE = 0xE0000000
HWREGS_UART_TX = 0x10

SYSVARS_BASE = 0x100
SYSVARS_HEAP_PTR = 0x00
SYSVARS_HEAP_END = 0x04

# #######################################################################
#                          Entry point
# #######################################################################
start:
ld SP, 0x4000000
jsr initializeMem
jsr /topLevel
jsr /main()

# Do a jump to address 0 (not a valid address) to stop the simulator
ld R30, 0
ret



# #######################################################################
#                          Print Function
# #######################################################################
# $1 = string to print   (length prefix format)

/print(String):
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    ldw $2, $1[-4]             # Load length of string
    add $2, $1                 # Pointer to just past the end of string
    jmp .cond

.loop:
    ldb $3, $1[0]               # Load character from string
    stw $3, $7[HWREGS_UART_TX]  # Print the character
    add $1, 1                   # Increment string pointer
.cond:
    bne $1, $2, .loop           # Repeat until string pointer is at end
    ret


# ==========================================================
#                     printInt
# ==========================================================
# $1 = value to print

/print(Int):
    sub $31, 16                # Allocate 16 bytes of stack space
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    bge $1, 0, .positive       # If value is positive, skip
    ld  $2, '-'                # Print the '-' character
    stw $2, $7[HWREGS_UART_TX]
    sub $1, 0, $1              # Negate the value

.positive:
    ld $6, $31                 # $6 = pointer to work space

.loop:
    modu $2, $1, 10            # $2 = $1 % 10
    divu $1, $1, 10            # $1 = $1 / 10
    add $2, '0'                # Convert digit to ASCII
    stb $2, $6[0]              # Store digit in work space
    add $6, 1                  # Increment work space pointer
    bne $1, 0, .loop           # Repeat until $1 is 0

.print:
    sub $6, 1                   # Decrement work space pointer
    ldb $2, $6[0]               # Load digit from work space
    stw $2, $7[HWREGS_UART_TX] # Print the digit
    bne $6, $31, .print         # Repeat until work space pointer is at base

.end:
    add $31, 16
    ret

# ==========================================================
#                     printChar
# ==========================================================
# $1 = character to print

/print(Char):
    ld $7, HWREGS_BASE         # Load base address of hardware registers
    stw $1, $7[HWREGS_UART_TX] # Print the character
    ret


# ==========================================================
#                     initializeMem
# ==========================================================
initializeMem:
ld $1, SYSVARS_BASE          # Load base address of system variables
ld $2, 0x1000                # Set Start of heap to address 4096 byte
stw $2, $1[SYSVARS_HEAP_PTR] # Store end of heap in system variables
ld $2, 0x3f00000             # Set end of heap to address 0x3f00000
stw $2, $1[SYSVARS_HEAP_END] # Store end of heap
ret

# ==========================================================
#                     malloc
# ==========================================================
# $1 = size in bytes to allocate
malloc:
ld $4, SYSVARS_BASE          # Load base address of system variables
ldw $2, $4[SYSVARS_HEAP_PTR] # Load current heap pointer
ldw $3, $4[SYSVARS_HEAP_END]  # Load end of heap

add $1,3                     # Round size up to multiple of 4 bytes
and $1, 0xFFFFFFFC
ld $8, $2                    # Save original heap pointer for return value
add $2, $1                   # Bump pointer
bge $2, $3, .outOfMemory     # Check if we have enough space
stw $2, $4[SYSVARS_HEAP_PTR] # Update heap pointer
ret

.outOfMemory:
ld $8, 0                     # Set return value to 0 (null pointer)
ret

# ==========================================================
#                     malloc Array
# ==========================================================
# $1 = number of elements
# $2 = size of each element in bytes
/mallocArray:
sub $sp, 8                # Allocate space on stack for two variables
stw $9, $sp[0]
stw $30, $sp[4]
ld $9, $1                 # Keep number of elements in $9
mul $1, $2                # Calculate total size in bytes
add $1, 4                 # Add space for header (length prefix)
jsr malloc                # Call malloc to allocate memory
beq $8, 0, .end           # Check if malloc failed
add $8, 4                 # Update pointer to point to first element
stw $9, $8[-4]            # Store number of elements at the start of
.end
ldw $30, $sp[4]           # Teardown stack frame
ldw $9, $sp[0]
add $sp, 8              # Restore stack pointer
ret


# ==========================================================
#                     bzero
# ==========================================================
# $1 = pointer to memory
# $2 = size in bytes to clear
/bzero:
beq $2, 0, .done         # If size is 0, nothing to do
add $4, $1, $2           # Calculate end pointer
or $3, $1, $4            # Check the start and end pointers are aligned
and $3, 3
bne $3, 0, .unaligned
.loop:
stw 0, $1[0]          # Store 0 at the current
add $1, 4
bne $1, $4, .loop      # Repeat until we reach the end
.done:
ret
.unaligned:
stb 0, $1[0]          # Store 0 at the current byte
add $1, 1
bne $1, $4, .unaligned # Repeat until we reach the end
ret