HWREGS = 0xE0000000
HWREGS_SEVEN_SEG     = 0x00
HWREGS_LEDR          = 0x04
HWREGS_SW            = 0x08
HWREGS_SIMULATION    = 0x2C     # Reads as 1 when running in simulation


ld   $20, 0              # error counter
ld   $21, 0xCAFEBABE     # pattern base
ld   $22, HWREGS
ld   $23, 0              # repetition counter

# in simulation set the end address to 0x2000 (8KB), on hardware 0x200000 (2MB)
ldw  $5, $22[HWREGS_SIMULATION]
ld   $2, 0x2000        # default end address in simulation (8KB)
bne  $5, 0, software
ld   $2, 0x200000      # end address on hardware (2MB)
software:

loop:
stw  $23, $22[HWREGS_LEDR] # show repetition count on LEDs

# Write phase
ld   $1, 0x1000          # base address in SDRAM
write_loop:
xor  $4, $1, $21         # pattern = addr ^ CAFEBABE
stw  $4, $1[0]           # store word
add  $1, $1, 4           # next address
blt  $1, $2, write_loop  # loop until end

#verify phase
# --- Verify phase ---
ld   $1, 0x1000          # reset addr to base
ldw  $6, $22[HWREGS_SW]  # read switches for error injection
verify_loop:
ldw  $5, $1[0]           # load back
xor  $4, $1, $21         # expected = addr ^ CAFEBABE
xor  $4, $4, $6          # inject errors based on switches
beq  $4, $5, next_addr
add  $20, $20, 1         # error counter++
stw  $20, $22[HWREGS_SEVEN_SEG] # show error pattern on 7-seg
next_addr:
add  $1, $1, 4
blt  $1, $2, verify_loop


# In simulation stop after one pass, on hardware loop forever
add  $23, $23, 1         # repetition counter++
add  $21, $21, 0x123     # change pattern
ldw  $5, $22[HWREGS_SIMULATION]
beq  $5, 0, loop    

ret