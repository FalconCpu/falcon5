

Busses in the design are named <master>_<slave>_<signal>

For example:-
    output logic        ifetch_icache_request,
    input  logic        ifetch_icache_ready,
    output logic        ifetch_icache_write,
    output logic [31:0] ifetch_icache_address,
    output logic        ifetch_icache_burst,
    output logic [3:0]  ifetch_icache_wstrb,
    output logic [31:0] ifetch_icache_wdata,
    input  logic [31:0] ifetch_icache_rdata,
    input  logic [31:0] ifetch_icache_raddr,
    input  logic [8:0]  ifetch_icache_rtag,
    input  logic        ifetch_icache_rvalid


To perform a write the bus master sets the address, write to 1, wstrb to indicate which bytes are valid,
and provides the data in wdata. The bus master must then not change the signals until a rising edge on clock
where ready is asserted.

To perform a read the bus master sets the address, write to 0, wstrb to zero, and provides the tag in wdata.
The bus master must then not change the signals until a rising edge on clock where ready is asserted.
Some time later the bus slave will respond with the data in rdata, the address in raddr, and the tag in rtag.
Requiring the slave to return the address is helpful for debugging, some masters may also use this. It is expected
(to bo confirmed) that synthesis tools will optimize away this bus if it is not used.

For most busses the master must always be ready to accept a response to any request it makes.  Occasionaly there
will need to be an interface with back pressure on the read data - these will also have an rready signal. But for
the most part, the master must always be ready to accept a response.

Bursts are only supported for read transactions, and are of a fixed size (TBD). All beats in the burst will return the same tag
(but the address will increment). Increments will be modulo the burst size.

In general a master cannot assume that reads will be returned in the same order as they were requested.