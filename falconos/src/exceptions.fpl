extern fun exit()

enum Exception(text:String) [
    NONE                     ("No Exception"),
    INSTRUCTION_ACCESS_FAULT ("Instruction access fault"),
    ILLEGAL_INSTRUCTION      ("Illegal instruction"),
    BREAKPOINT               ("Breakpoint"),
    LOAD_ADDRESS_MISALIGNED  ("Load address misaligned"),
    LOAD_ACCESS_FAULT        ("Load access fault"),
    STORE_ADDRESS_MISALIGNED ("Store address misaligned"),
    STORE_ACCESS_FAULT       ("Store access fault"),
    SYSTEM_CALL              ("System Call"),
    INDEX_OVERFLOW           ("Index Overflow") ]

const SYSCALL_END_TASK     = 0x00
const SYSCALL_YIELD        = 0x01
const SYSCALL_FIND_TASK    = 0x02
const SYSCALL_SEND_MESSAGE = 0x03
const SYSCALL_GET_MESSAGE  = 0x04
const SYSCALL_POLL_MESSAGE = 0x05
const SYSCALL_ALLOC_MEM    = 0x06
const SYSCALL_FREE_MEM     = 0x07   
const SYSCALL_OPEN_FILE    = 0x10
const SYSCALL_CLOSE_FILE   = 0x11
const SYSCALL_READ_FILE    = 0x12
const SYSCALL_WRITE_FILE   = 0x13

# The following syscalls are only allowed from system tasks
const SYSCALL_FILE_OPENED  = 0x20
const SYSCALL_FILE_CLOSED  = 0x21
const SYSCALL_IO_ERROR     = 0x22
const SYSCALL_IO_RESULT    = 0x23


fun dumpException(cause:Exception, data:Int)
    kprintf("EXCEPTION %s DATA=%08x\n", cause.text, data)
    # print the register state of the current task
    allTasks.dump()
    exit()

fun endTask(task:TaskControlBlock)
    kprintf("Ending task '%s'\n", task.name)
    # remove task from readyTasks list
    if task.runState = TaskState.READY
        task.prevReady.nextReady = task.nextReady
        task.nextReady.prevReady = task.prevReady
    # remove task from allTasks list
    task.prevTask.nextTask = task.nextTask
    task.nextTask.prevTask = task.prevTask
    free task

fun exceptionHandler(cause:Exception, data:Int, task:TaskControlBlock)
    var advancePC = true

    if (cause=Exception.SYSTEM_CALL)
        when (data)
            SYSCALL_END_TASK ->
                endTask(task)

            SYSCALL_YIELD    ->
               val dummy = 0  # just return to the scheduler

            SYSCALL_FIND_TASK->  
                val name = unsafe(task.regs[1] as String)
                val t = findTaskByName(name)
                task.regs[8] = unsafe(t as Int)

            SYSCALL_SEND_MESSAGE ->
                val t = unsafe(task.regs[1] as TaskControlBlock)
                val msg = new Message(task.regs[2], task.regs[3], task.regs[4], task.regs[5])
                t.addMessage(msg)

            SYSCALL_GET_MESSAGE  ->
                val msg = task.firstMessage
                if msg=null
                    task.setBlocked()
                    advancePC = false       # don't advance PC - when task is resumed it will re-issue the syscall
                else
                    task.regs[8] = msg.data0
                    task.regs[7] = msg.data1
                    task.regs[6] = msg.data2
                    task.regs[5] = msg.data3
                    task.firstMessage = msg.next
                    if task.firstMessage=null
                        task.lastMessage = null
                    free msg  

            SYSCALL_POLL_MESSAGE ->
                val msg = task.firstMessage
                if msg=null
                    task.regs[8] = 0
                else
                    task.regs[8] = 1

            SYSCALL_ALLOC_MEM ->
                val size = task.regs[1]
                val permission = task.regs[2]
                val mem = task.allocMem(size, permission)  # TODO check for failure
                task.regs[8] = mem

            SYSCALL_FREE_MEM  ->
                val mem = task.regs[1]      # TODO check that this memory was allocated to this task
                task.freeMem(mem)

            SYSCALL_OPEN_FILE ->
                val filename = unsafe(task.regs[1] as String)
                val mode = task.regs[2]
                val driver = if (filename="CON:") then terminalTask else filesysTask
                kprintf("openFile %s mode %d\n", filename, mode)
                val msg = new Message(MESSAGE_OPEN, task.regs[1], task.regs[2],unsafe(task as Int))
                filesysTask.addMessage(msg)
                task.setBlockedIO()
    
            SYSCALL_CLOSE_FILE ->
                kprintf("closeFile not implemented\n")
                abort ABORT_NOT_IMPLEMENTED

            SYSCALL_READ_FILE  ->
                val fd = unsafe(task.regs[1] as FileHandle) # TODO check that this file handle belongs to this task
                val ptr = unsafe(task.regs[2] as Pointer<Char>) # TODO check that this pointer is in the task's memory space
                val len = task.regs[3]
                val msg = new Message(MESSAGE_READ, task.regs[1], task.regs[2], task.regs[3])
                fd.handler.addMessage(msg)
                task.setBlockedIO()

            SYSCALL_WRITE_FILE ->
                task.setBlockedIO()
                val fd = unsafe(task.regs[1] as FileHandle) # TODO check that this file handle belongs to this task
                val msg = new Message(MESSAGE_WRITE, task.regs[1], task.regs[2], task.regs[3])
                fd.handler.addMessage(msg)
                
            SYSCALL_FILE_OPENED ->
                # TODO - check that this syscall is from a system task
                kprintf("SYSCALL_FILE_OPENED\n")
                val fd = unsafe(task.regs[1] as FileHandle) 
                val destTask = fd.task
                if destTask.runState != TaskState.BLOCKED_IO
                    kprintf("Error: SYSCALL_FILE_OPENED but task '%s' not blocked on I/O\n", destTask.name)
                    abort ABORT_INVALID_STATE
                destTask.regs[8] = 0                  # success
                destTask.regs[7] = unsafe(fd as Int)  # host file handle
                destTask.setReady()

            SYSCALL_FILE_CLOSED ->
                # TODO - check that this syscall is from a system task  
                kprintf("SYSCALL_FILE_CLOSED not implemented\n")
                abort ABORT_NOT_IMPLEMENTED

            SYSCALL_IO_ERROR  ->
                # TODO - check that this syscall is from a system task
                val destTask = unsafe(task.regs[1] as TaskControlBlock)
                val error = task.regs[2]
                if destTask.runState != TaskState.BLOCKED_IO
                    kprintf("Error: SYSCALL_IO_ERROR but task '%s' not blocked on I/O\n", destTask.name)
                    abort ABORT_INVALID_STATE
                destTask.regs[8] = 1
                destTask.regs[7] = error
                destTask.setReady()

            SYSCALL_IO_RESULT  ->
                # TODO - check that this syscall is from a system task
                val destTask = unsafe(task.regs[1] as TaskControlBlock)
                val result = task.regs[2]
                if destTask.runState != TaskState.BLOCKED_IO
                    kprintf("Error: SYSCALL_IO_RESULT but task '%s' not blocked on I/O\n", destTask.name)
                    abort ABORT_INVALID_STATE
                destTask.regs[8] = 0
                destTask.regs[7] = result
                destTask.setReady()


            else -> 
                kprintf("Unknown syscall %x from task '%s'\n", data, task.name)
    else
        dumpException(cause, data)

    # advance the PC of the task to the next instruction
    if advancePC
        task.regs[0] += 4

    runScheduler()