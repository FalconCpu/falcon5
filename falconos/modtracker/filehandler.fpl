
# ===================================================================
# UART frame format:
# 0xB0 0x02    ( 2 bytes - start of frame marker)
# Command word ( 2 bytes)
# Length       ( 4 bytes)
# Data         (Length bytes)
# Checksum     ( 4 bytes - sum of all bytes up to this point)
# ===================================================================

var checksum = 0

const NETFS_CMD_OPEN   = 0x0101
const NETFS_CMD_CLOSE  = 0x0102
const NETFS_CMD_READ   = 0x0103
const NETFS_CMD_WRITE  = 0x0104
const NETFS_RESP_OK    = 0x0201
const NETFS_RESP_ERROR = 0x0202

fun uartSendByte(b: Int)
    while hwregs.uart_tx < 2 # wait for space in FIFO
        val dummy = 1       # TODO - consider yielding here if blocking is acceptable
    hwregs.uart_tx = b & 0xFF
    checksum += b & 0xFF

fun uartSendWord(w: Int)
    uartSendByte((w lsr 0) & 0xFF)
    uartSendByte((w lsr 8) & 0xFF)
    uartSendByte((w lsr 16) & 0xFF)
    uartSendByte((w lsr 24) & 0xFF)

fun uartSendFrame(command:Int, length:Int, data:Pointer<Char>)
    checksum = 0
    uartSendByte(0xB0)
    uartSendByte(0x02)
    uartSendByte(command & 0xFF)
    uartSendByte((command lsr 8) & 0xFF)
    uartSendWord(length)
    for i in 0..<length
        uartSendByte(data[i] as Int)
    uartSendWord(checksum)

fun uartSendFrame(command:Int, data1:Int, data2:Int)
    checksum = 0
    uartSendByte(0xB0)
    uartSendByte(0x02)
    uartSendByte(command & 0xFF)
    uartSendByte((command lsr 8) & 0xFF)
    uartSendWord(8)
    uartSendWord(data1)
    uartSendWord(data2)
    uartSendWord(checksum)


fun uartSendFrame(command:Int, word:Int, length:Int, data:Pointer<Char>)
    checksum = 0
    uartSendByte(0xB0)
    uartSendByte(0x02)
    uartSendByte(command & 0xFF)
    uartSendByte((command lsr 8) & 0xFF)
    uartSendWord(length+4)
    uartSendWord(word)
    for i in 0..<length
        uartSendByte(data[i] as Int)
    uartSendWord(checksum)

fun uartSendFrame(command:Int, string:String)
    checksum = 0
    uartSendByte(0xB0)
    uartSendByte(0x02)
    uartSendByte(command & 0xFF)
    uartSendByte((command lsr 8) & 0xFF)
    uartSendWord(string.length)
    for i in 0..<string.length
        uartSendByte(string[i] as Int)
    uartSendWord(checksum)


fun uartReceiveByte() -> Int!
    var count = 0
    repeat
        val data = hwregs.uart_rx
        if data != -1
            val ret = data & 0xFF
            checksum += ret
            return ret
        count += 1
        if count > 10000000
            kprintf("uartReceiveByte: timeout\n")
            return Error.TIMEOUT
    until false

fun uartReceiveCommand() -> Int!
    #kprintf("uartReceiveCommand: waiting for command\n")
    var cmd = 0
    var state = 0
    while true
        val b = try uartReceiveByte()
        if (state=0 and b=0xB0)
            state = 1
        else if (state=1 and b=0x02)
            state = 2
        else if (state=2)
            cmd = b
            state = 3
        else if (state=3)
            cmd = cmd | (b lsl 8)
            return cmd
        else
            kprintf("uartReceiveCommand: invalid byte %x in state %d\n", b, state)
            state = 0

fun uartRecieveInt() -> Int!
    var ret = 0
    for i in 0..3
        val b = try uartReceiveByte()
        ret = ret | (b lsl (i*8))
    return ret

class UartFrame(val command:Int, val data:Array<Char>)

fun uartReceiveFrame() -> UartFrame!
    val cmd = try uartReceiveCommand()
    val length = try uartRecieveInt()
    checksum = 0
    hwregs.count_rx_bytes = 0
    if length < 0 or length > 2000000
        return Error.INVALID_ARGUMENT
    val data = unsafe(new Array<Char>(length))  # Unsafe alloc to avoid zeroing large buffers
    # kprintf("uartReceiveFrame: receiving %d bytes\n", length)
    for i in 0..<length
        val overflow = hwregs.fifo_overflow
        if overflow != 0
            kprintf("uartReceiveFrame: fifo overflow detected at bit %d: %d\n", i, overflow)
            free data
            return Error.IO_ERROR
        val b = uartReceiveByte()
        hwregs.seven_seg = i
        if (b is Error)
            kprintf("uartReceiveFrame: error receiving data byte %d [%d]: %s %d\n", i, hwregs.count_rx_bytes,  b.message, hwregs.fifo_overflow)
            free data
            return b
        data[i] = unsafe(b as Char)
    val calcChecksum = checksum
    kprintf("uartReceiveFrame: received %d bytes, checksum=%x\n", length, calcChecksum)
    val recvChecksum = uartRecieveInt()
    if recvChecksum is Error
        kprintf("uartReceiveFrame: error receiving checksum: %s %x\n", recvChecksum.message, hwregs.fifo_overflow)
        free data
        return recvChecksum
    kprintf("uartReceiveFrame: received checksum %x\n", recvChecksum)
    if recvChecksum != calcChecksum
        kprintf("uartReceiveFrame: checksum error, expected %x got %x\n", recvChecksum, calcChecksum)
        return Error.IO_ERROR
    return new UartFrame(cmd, data)

class UartFrame1(val cmd:Int, val data:Int)

fun uartReceiveFrame1() -> UartFrame1!
    checksum = 0
    val cmd = try uartReceiveCommand()
    val length = try uartRecieveInt()
    if length != 4
        kprintf("uartReceiveFrame: expected length 4, got %d\n", length)
        return Error.IO_ERROR
    val data = try uartRecieveInt()
    val csum = checksum
    val recvChecksum = try uartRecieveInt()
    if recvChecksum != csum
        kprintf("uartReceiveFrame: checksum error, expected %x got %x\n", recvChecksum, csum)
        return Error.IO_ERROR
    return new UartFrame1(cmd, data)



fun readFile(filename:String) -> Array<Char>!
    kprintf("readFile: filename=%s\n", filename)
    
    val overflow = hwregs.fifo_overflow
    if overflow != 0
        kprintf("readFile: fifo overflow detected at start: %d\n", overflow)
        return Error.IO_ERROR


    uartSendFrame(NETFS_CMD_OPEN, filename)

    val overflow2= hwregs.fifo_overflow
    if overflow2 != 0
        kprintf("readFile: fifo overflow detected after send: %d\n", overflow2)
        return Error.IO_ERROR


    val frame = try uartReceiveFrame()
    if frame.command != NETFS_RESP_OK
        kprintf("readFile: open failed, command=%x\n", frame.command)
        free frame.data
        return Error.IO_ERROR

    return frame.data
