# We use the 0x88 board representation for efficient move generation and legality checks.
# Each square is represented by an index from 0 to 127, where the valid squares are those where (index & 0x88) = 0

const INVALID_MASK = 0x88
const RANK_MASK = 0x70
const FILE_MASK = 0x07
const RANK_MULT = 16

const PIECE_PAWN = 2
const PIECE_KNIGHT = 4
const PIECE_BISHOP = 6
const PIECE_ROOK = 8
const PIECE_QUEEN = 10
const PIECE_KING = 12
const PIECE_MASK = 0xE   # Mask to extract piece type (ignoring color)
const COLOR_MASK = 1     # Mask to extract color bit
const PIECE_WHITE = 0
const PIECE_BLACK = 1

const LEVEL = 4

# Transposition table bound types
const TT_EXACT = 0       # Exact score (PV node)
const TT_LOWER_BOUND = 1 # Beta cutoff (score >= beta)
const TT_UPPER_BOUND = 2 # Alpha cutoff (score <= alpha)

# Transposition table entry
struct TTEntry(hash:Int, score:Int, depth:Int, boundType:Int)

const TT_SIZE = 65536
val transpositionTable = new Array<TTEntry>(TT_SIZE)
var ttHits = 0
var ttStores = 0
var ttProbes = 0
var ttHashMatches = 0
var ttDepthFailures = 0
var ttBoundRejections = 0


val board = new Array<Int>(128)  # 16x8 board, only indices where (index & 0x88) = 0 are valid
var enPassantSquare = -1  # Index of en passant target square, or -1 if none
var totalMoves = 0
var score = 0
var useBook = true

# Zobrist hashing for position detection
val zobristPieces = new Array<Int>(128 * 14)  # 128 squares * 14 piece types (7 pieces * 2 colors)
val zobristEnPassant = new Array<Int>(8)      # En-passant file (0-7)
var zobristSideToMove = 0                     # XOR this when switching sides
var currentHash = 0                           # Current position hash

# Statistics for measuring transposition table performance
var totalPositionsEvaluated = 0

# Killer move heuristic - store moves that caused beta cutoffs
const MAX_PLY = 20
val killerMoves1 = new Array<Int>(MAX_PLY)  # Store as (from << 8) | to
val killerMoves2 = new Array<Int>(MAX_PLY)  # Second killer per ply
var killerHits = 0
var killerStores = 0

fun initializeKillerMoves()
    for i in 0..<MAX_PLY
        killerMoves1[i] = -1
        killerMoves2[i] = -1
    killerHits = 0
    killerStores = 0

fun storeKiller(from:Int, to:Int, ply:Int)
    if ply >= MAX_PLY
        return
    val moveKey = (from lsl 8) | to
    # Don't store duplicates
    if killerMoves1[ply] = moveKey
        return
    # Shift killers: killer1 becomes killer2, new move becomes killer1
    killerMoves2[ply] = killerMoves1[ply]
    killerMoves1[ply] = moveKey
    killerStores += 1

fun isKillerMove(from:Int, to:Int, ply:Int) -> Bool
    if ply >= MAX_PLY
        return false
    val moveKey = (from lsl 8) | to
    return killerMoves1[ply] = moveKey or killerMoves2[ply] = moveKey

fun simpleRandom(seed:Int) -> Int
    # Simple LCG random number generator
    val temp = seed * 1103515245 + 12345
    return if temp < 0 then -temp else temp

fun initializeZobrist()
    var seed = 0x12345678
    # Initialize piece-square zobrist values
    for i in 0..<(128*14)
        seed = simpleRandom(seed)
        zobristPieces[i] = seed
    
    # Initialize en-passant zobrist values
    for i in 0..<8
        seed = simpleRandom(seed)
        zobristEnPassant[i] = seed
    
    # Initialize side-to-move zobrist value
    seed = simpleRandom(seed)
    zobristSideToMove = seed
    
    kprintf("Zobrist hashing initialized\n")

fun getPieceZobristIndex(piece:Int) -> Int
    # Map piece value to zobrist index (0-13)
    # PIECE_PAWN=2, KNIGHT=4, BISHOP=6, ROOK=8, QUEEN=10, KING=12
    # Color bit is 0 or 1
    val pieceType = (piece & PIECE_MASK) lsr 1  # 1-6
    val color = piece & COLOR_MASK              # 0-1
    return (pieceType - 1) * 2 + color

fun getZobristPiece(piece:Int, square:Int) -> Int
    # Get zobrist value for a piece at a square
    val pieceIndex = getPieceZobristIndex(piece)
    return zobristPieces[square * 14 + pieceIndex]

fun getZobristEnPassant(file:Int) -> Int
    # Get zobrist value for en-passant on a file
    return zobristEnPassant[file]

fun computeHash() -> Int
    # Compute hash from scratch for current board position using XOR
    var hash = 0
    for i in 0..<128
        val piece = board[i]
        if piece != 0
            hash = hash ^ getZobristPiece(piece, i)
    
    # Include en-passant in hash
    if enPassantSquare != -1
        val file = enPassantSquare & FILE_MASK
        hash = hash ^ getZobristEnPassant(file)
    
    return hash

fun hashTogglePiece(piece:Int, square:Int)
    # Toggle a piece in the hash (XOR is its own inverse, so same for add/remove)
    currentHash = currentHash ^ getZobristPiece(piece, square)

fun hashToggleEnPassant(square:Int)
    # Toggle en-passant in hash (XOR is its own inverse)
    if square != -1
        val file = square & FILE_MASK
        currentHash = currentHash ^ getZobristEnPassant(file)

fun initializeTranspositionTable()
    # Initialize all TT entries to empty
    for i in 0..<TT_SIZE
        transpositionTable[i] = TTEntry(0, 0, -1, TT_EXACT)
    ttHits = 0
    ttStores = 0
    kprintf("Transposition table initialized (%d entries)\n", TT_SIZE)

fun probeTranspositionTable(hash:Int, depth:Int, alpha:Int, beta:Int) -> Int
    # Probe the transposition table. Returns score if usable, otherwise returns -999999
    ttProbes += 1  # Count every probe attempt
    
    val absHash = if hash < 0 then -hash else hash
    val index = absHash % TT_SIZE
    val entry = transpositionTable[index]
    
    # Check if hash matches
    if entry.hash = hash
        # Hash matches - now check depth
        if entry.depth >= depth
            ttHashMatches += 1  # Hash and depth both good
            ttHits += 1  # Keep original hit counter
            
            # Check if we can use this cached result
            if entry.boundType = TT_EXACT
                return entry.score
            elsif entry.boundType = TT_LOWER_BOUND
                if entry.score >= beta
                    return entry.score
            elsif entry.boundType = TT_UPPER_BOUND
                if entry.score <= alpha
                    return entry.score
            
            # We had a match but bounds didn't let us use it
            ttBoundRejections += 1
        else
            # Hash matches but depth is insufficient
            ttDepthFailures += 1
    
    return -999999  # Sentinel value meaning "not usable"

fun storeTranspositionTable(hash:Int, score:Int, depth:Int, originalAlpha:Int, beta:Int)
    # Store a position in the transposition table
    val absHash = if hash < 0 then -hash else hash
    val index = absHash % TT_SIZE
    
    # Determine bound type based on how the search ended
    var boundType = TT_EXACT
    if score <= originalAlpha
        boundType = TT_UPPER_BOUND  # Failed low
    elsif score >= beta
        boundType = TT_LOWER_BOUND  # Failed high (beta cutoff)
    
    # Depth-preferred replacement: only replace if new depth is deeper or hashes match
    val existingEntry = transpositionTable[index]
    if existingEntry.hash = hash or depth >= existingEntry.depth
        transpositionTable[index] = TTEntry(hash, score, depth, boundType)
        ttStores += 1

fun recordPosition(hash:Int)
    # Just count total positions - tracking unique positions is not feasible with current memory
    totalPositionsEvaluated += 1

fun printHashStatistics()
    val ttHitRate = if totalPositionsEvaluated > 0 then (ttHits * 100) / totalPositionsEvaluated else 0
    val hashMatchRate = if ttProbes > 0 then (ttHashMatches * 100) / ttProbes else 0
    val depthFailureRate = if ttProbes > 0 then (ttDepthFailures * 100) / ttProbes else 0
    val boundRejectionRate = if ttProbes > 0 then (ttBoundRejections * 100) / ttProbes else 0
    val avgOverwrites = if TT_SIZE > 0 then ttStores / TT_SIZE else 0
    
    kprintf("\n=== Transposition Table Statistics ===\n")
    kprintf("Total positions evaluated: %d\n", totalPositionsEvaluated)
    kprintf("TT size: %d entries\n", TT_SIZE)
    kprintf("TT stores: %d (~%dx overwrites per slot)\n", ttStores, avgOverwrites)
    kprintf("TT probes: %d\n", ttProbes)
    kprintf("TT hash matches: %d (%d%% of probes)\n", ttHashMatches, hashMatchRate)
    kprintf("TT depth failures: %d (%d%% of probes)\n", ttDepthFailures, depthFailureRate)
    kprintf("TT bound rejections: %d (%d%% of probes)\n", ttBoundRejections, boundRejectionRate)
    kprintf("TT hits (usable): %d (%d%% of positions)\n", ttHits, ttHitRate)
    kprintf("\n=== Killer Move Statistics ===\n")
    kprintf("Killer stores: %d\n", killerStores)
    kprintf("Killer hits: %d\n", killerHits)
    kprintf("===================================================\n\n")

fun resetHashStatistics()
    totalPositionsEvaluated = 0
    ttHits = 0
    ttStores = 0
    ttProbes = 0
    ttHashMatches = 0
    ttDepthFailures = 0
    ttBoundRejections = 0
    initializeKillerMoves()

fun abs(x:Int) -> Int
    return if x < 0 then -x else x

fun initializePieces(board:Array<Int>)
    for i in 0..<128
        board[i] = 0
    board[0] = PIECE_ROOK | PIECE_WHITE
    board[1] = PIECE_KNIGHT | PIECE_WHITE
    board[2] = PIECE_BISHOP | PIECE_WHITE
    board[3] = PIECE_QUEEN | PIECE_WHITE
    board[4] = PIECE_KING | PIECE_WHITE
    board[5] = PIECE_BISHOP | PIECE_WHITE
    board[6] = PIECE_KNIGHT | PIECE_WHITE
    board[7] = PIECE_ROOK | PIECE_WHITE
    board[112] = PIECE_ROOK | PIECE_BLACK
    board[113] = PIECE_KNIGHT | PIECE_BLACK
    board[114] = PIECE_BISHOP | PIECE_BLACK
    board[115] = PIECE_QUEEN | PIECE_BLACK
    board[116] = PIECE_KING | PIECE_BLACK
    board[117] = PIECE_BISHOP | PIECE_BLACK
    board[118] = PIECE_KNIGHT | PIECE_BLACK
    board[119] = PIECE_ROOK | PIECE_BLACK
    for i in 0..<8
        board[i+16] = PIECE_PAWN | PIECE_WHITE
        board[i+96] = PIECE_PAWN | PIECE_BLACK


# =======================================================================
#                   Move Structure
# =======================================================================

fun printSquare(index:Int)
    val file = index & FILE_MASK
    val rank = index lsr 4
    kprintf("%c%d", ('a' as Int) + file, rank + 1)

struct Move(from:Int, to:Int, piece:Int, captured:Int, enPassant:Bool)
class MoveList
    var count = 0
    var moves : InlineArray<Move>(256)
    fun addMove(from:Int, to:Int)
        val piece = board[from]
        val captured = board[to]
        moves[count] = Move(from, to, piece, captured, false)
        count += 1

    fun addEnPassantMove(from:Int, to:Int)
        val piece = board[from]
        val captured = 0  # En-passant captures an empty square
        moves[count] = Move(from, to, piece, captured, true)
        count += 1

    fun clear()
        count = 0

    fun invalidateMove(index:Int)
        moves[index] = Move(-1, -1, 0, 0, false)  # Mark move as invalid

    fun printMove(index:Int)
        val move = moves[index]
        if move.from = -1
            kprintf("Invalid move\n")
            return
        printSquare(move.from)
        if move.captured != 0
            kprintf("x")
        else
            kprintf("-")
        printSquare(move.to)

    fun findMove(from:Int, to:Int) -> Int
        for i in 0..<count
            if moves[i].from = from and moves[i].to = to
                return i
        return -1

    fun printMoves()
        for i in 0..<count
            printMove(i)
            kprintf("\n")

    fun countMoves() -> Int
        var validCount = 0
        for i in 0..<count
            if moves[i].from != -1
                validCount += 1
        return validCount

    fun swapMoves(i:Int, j:Int)
        val temp = moves[i]
        moves[i] = moves[j]
        moves[j] = temp

fun makeMove(move:Move)
    # Update hash - remove old en-passant
    hashToggleEnPassant(enPassantSquare)
    
    # Update hash - remove piece from 'from' square
    hashTogglePiece(move.piece, move.from)
    
    # Update hash - remove captured piece from 'to' square (if any)
    if move.captured != 0
        hashTogglePiece(move.captured, move.to)
    
    # Update board
    board[move.to] = move.piece
    board[move.from] = 0
    score += getPieceValue(move.piece, move.to) - getPieceValue(move.piece, move.from)
    if move.captured != 0
        score -= getPieceValue(move.captured, move.to)

    # Handle en-passant capture
    if move.enPassant
        val capturedPawnSquare = if (move.piece&COLOR_MASK)=PIECE_WHITE then move.to - RANK_MULT else move.to + RANK_MULT
        val opponentColor = 1 - (move.piece&COLOR_MASK)
        val capturedPawn = PIECE_PAWN | opponentColor
        hashTogglePiece(capturedPawn, capturedPawnSquare)
        board[capturedPawnSquare] = 0
        score -= getPieceValue(capturedPawn, capturedPawnSquare)

    # Update hash - add piece to 'to' square (before promotion check)
    var finalPiece = move.piece
    
    # Check for pawn promotion
    if move.piece&PIECE_MASK=PIECE_PAWN
        if move.to&RANK_MASK = 7*RANK_MULT
            finalPiece = PIECE_QUEEN | PIECE_WHITE
            board[move.to] = finalPiece
            score += getPieceValue(finalPiece, move.to) - getPieceValue(move.piece, move.to)
        elsif move.to&RANK_MASK = 0
            finalPiece = PIECE_QUEEN | PIECE_BLACK
            board[move.to] = finalPiece
            score += getPieceValue(finalPiece, move.to) - getPieceValue(move.piece, move.to)
    
    # Update hash with final piece (after promotion)
    hashTogglePiece(finalPiece, move.to)

    # Check for castling
    if move.piece&PIECE_MASK=PIECE_KING
        if move.to = move.from + 2  # Kingside castling
            val rook = board[move.from + 3]
            hashTogglePiece(rook, move.from + 3)
            board[move.from + 1] = rook
            board[move.from + 3] = 0
            hashTogglePiece(rook, move.from + 1)
            score += getPieceValue(rook, move.from + 1) - getPieceValue(rook, move.from + 3)
        elsif move.to = move.from - 2  # Queenside castling
            val rook = board[move.from - 4]
            hashTogglePiece(rook, move.from - 4)
            board[move.from - 1] = rook
            board[move.from - 4] = 0
            hashTogglePiece(rook, move.from - 1)
            score += getPieceValue(rook, move.from - 1) - getPieceValue(rook, move.from - 4)

    # Handle setting en passant square
    if move.piece&PIECE_MASK=PIECE_PAWN and abs(move.to - move.from) = 2*RANK_MULT
        enPassantSquare = (move.from + move.to) / 2
        hashToggleEnPassant(enPassantSquare)
    else
        enPassantSquare = -1

fun undoMove(move:Move)
    board[move.from] = move.piece
    board[move.to] = move.captured
    
    # Undo en-passant capture
    if move.enPassant
        val capturedPawnSquare = if (move.piece&COLOR_MASK)=PIECE_WHITE then move.to - RANK_MULT else move.to + RANK_MULT
        val opponentColor = 1 - (move.piece&COLOR_MASK)
        board[capturedPawnSquare] = PIECE_PAWN | opponentColor
    
    # Undo castling
    if move.piece&PIECE_MASK=PIECE_KING
        if move.to = move.from + 2  # Kingside castling
            board[move.from + 3] = board[move.from + 1]  # Move rook back
            board[move.from + 1] = 0
        elsif move.to = move.from - 2  # Queenside castling
            board[move.from - 4] = board[move.from - 1]  # Move rook back
            board[move.from - 1] = 0

# =======================================================================
#                   Piece value
# =======================================================================

const pawnTable = const Array<Int>[
  0,   0,  0,   0,    0,   0,  0,    0,   0,0,0,0,0,0,0,0,
 105, 110,  110, 80,   80, 110, 110, 105, 0,0,0,0,0,0,0,0,
 105, 95,   90, 100, 100,  90,  95, 105,  0,0,0,0,0,0,0,0,
 100, 100, 100, 120, 120, 100, 100, 100,  0,0,0,0,0,0,0,0,
 105, 105, 110, 125, 125, 110, 105, 105,  0,0,0,0,0,0,0,0,
 110, 110, 120, 130, 130, 120, 110, 110,  0,0,0,0,0,0,0,0,
 150, 150, 150, 150, 150, 150, 150, 150,  0,0,0,0,0,0,0,0,
 900, 900, 900, 900, 900, 900, 900, 900,  0,0,0,0,0,0,0,0]

const knightTable = const Array<Int>[
 250, 260, 270, 270, 270, 270, 260, 250, 0,0,0,0,0,0,0,0,
 260, 280, 300, 305, 305, 300, 280, 260, 0,0,0,0,0,0,0,0,
 270, 305, 310, 315, 315, 310, 305, 270, 0,0,0,0,0,0,0,0,
 270, 300, 315, 320, 320, 315, 300, 270, 0,0,0,0,0,0,0,0,
 270, 305, 315, 320, 320, 315, 305, 270, 0,0,0,0,0,0,0,0,
 270, 300, 310, 315, 315, 310, 300, 270, 0,0,0,0,0,0,0,0,
 260, 280, 300, 300, 300, 300, 280, 260, 0,0,0,0,0,0,0,0,
 250, 260, 270, 270, 270, 270, 260, 250, 0,0,0,0,0,0,0,0]

const bishopTable = const Array<Int>[
 280, 290, 290, 290, 290, 290, 290, 280, 0,0,0,0,0,0,0,0,
 290, 305, 300, 300, 300, 300, 305, 290, 0,0,0,0,0,0,0,0,
 290, 310, 310, 310, 310, 310, 310, 290, 0,0,0,0,0,0,0,0,
 290, 300, 310, 310, 310, 310, 300, 290, 0,0,0,0,0,0,0,0,
 290, 305, 305, 310, 310, 305, 305, 290, 0,0,0,0,0,0,0,0,
 290, 300, 305, 310, 310, 305, 300, 290, 0,0,0,0,0,0,0,0,
 290, 300, 300, 300, 300, 300, 300, 290, 0,0,0,0,0,0,0,0,
 280, 290, 290, 290, 290, 290, 290, 280, 0,0,0,0,0,0,0,0]

const rookTable = const Array<Int>[
  500,  500, 505, 510, 510, 505, 500, 500, 0,0,0,0,0,0,0,0,
  495,  500, 500, 500, 500, 500, 500, 495, 0,0,0,0,0,0,0,0,
  495,  500, 500, 500, 500, 500, 500, 495, 0,0,0,0,0,0,0,0,
  495,  500, 500, 500, 500, 500, 500, 495, 0,0,0,0,0,0,0,0,
  495,  500, 500, 500, 500, 500, 500, 495, 0,0,0,0,0,0,0,0,
  495,  500, 500, 500, 500, 500, 500, 495, 0,0,0,0,0,0,0,0,
  505,  510, 510, 510, 510, 510, 510, 505, 0,0,0,0,0,0,0,0,
  500,  500, 500, 500, 500, 500, 500, 500, 0,0,0,0,0,0,0,0]

const queenTable = const Array<Int>[
 880, 891, 890, 895, 895, 890, 890, 880,   0,0,0,0,0,0,0,0,
 890, 900, 900, 900, 900, 900, 900, 890,   0,0,0,0,0,0,0,0,
 890, 900, 905, 905, 905, 905, 900, 890,   0,0,0,0,0,0,0,0,
 895, 900, 905, 905, 905, 905, 900, 895,   0,0,0,0,0,0,0,0,
 900, 900, 905, 905, 905, 905, 900, 895,   0,0,0,0,0,0,0,0,
 890, 905, 905, 905, 905, 905, 900, 890,   0,0,0,0,0,0,0,0,
 890, 900, 905, 900, 900, 900, 900, 890,   0,0,0,0,0,0,0,0,
 880, 890, 890, 895, 895, 890, 890, 880,   0,0,0,0,0,0,0,0]

const kingTable = const Array<Int>[
  9970, 9960, 9960, 9950, 9950, 9960, 9960, 9970, 0,0,0,0,0,0,0,0,
  9970, 9960, 9960, 9950, 9950, 9960, 9960, 9970, 0,0,0,0,0,0,0,0,
  9970, 9960, 9960, 9950, 9950, 9960, 9960, 9970, 0,0,0,0,0,0,0,0,
  9970, 9960, 9960, 9950, 9950, 9960, 9960, 9970, 0,0,0,0,0,0,0,0,
  9980, 9970, 9970, 9960, 9960, 9970, 9970, 9980, 0,0,0,0,0,0,0,0,
  9990, 9980, 9980, 9980, 9980, 9980, 9980, 9990, 0,0,0,0,0,0,0,0,
 10020,10020,10000,10000,10000,10000,10020,10020, 0,0,0,0,0,0,0,0,
 10020,10030,10010,10000,10000,10010,10030,10020, 0,0,0,0,0,0,0,0]



fun getPieceValue(piece:Int, square:Int) -> Int
    val value:Int
    val sq = if (piece&COLOR_MASK) = PIECE_WHITE then square else 119 - square  # Mirror the board for black pieces
    when piece & PIECE_MASK
        PIECE_PAWN -> value = pawnTable[sq]
        PIECE_KNIGHT -> value = knightTable[sq]
        PIECE_BISHOP -> value = bishopTable[sq]
        PIECE_ROOK -> value = rookTable[sq]
        PIECE_QUEEN -> value = queenTable[sq]
        PIECE_KING -> value = kingTable[sq]
        else -> value = 0
    if (piece&COLOR_MASK) = PIECE_WHITE
        return value
    else
        return -value


# =======================================================================
#                  Move Generation and Validation
# =======================================================================

fun isEmptyOrOpponent(index:Int, player:Int) -> Bool
    return board[index] = 0 or (board[index]&COLOR_MASK) != player

fun isOccupiedByOwnPiece(index:Int, player:Int) -> Bool
    return board[index] != 0 and (board[index]&COLOR_MASK) = player

const knight_move_offsets = const Array<Int>[31, 33, 14, -14, -31, -33, 18, -18]
const bishop_move_offsets = const Array<Int>[15, 17, -15, -17]
const rook_move_offsets = const Array<Int>[16, -16, 1, -1]
const queen_move_offsets = const Array<Int>[15, 17, -15, -17, 16, -16, 1, -1]
const king_move_offsets = const Array<Int>[15, 17, -15, -17, 16, -16, 1, -1]

# Find all pseudo-legal moves for the current player (ignoring checks)
fun generatePseudoLegalMoves(moveList:MoveList, player:Int)
    moveList.clear()
    for y in 0..<8
        for x in 0..<8
            val index = y*RANK_MULT + x
            val piece = board[index]
            if piece != 0 and (piece&COLOR_MASK) = player
                when piece&PIECE_MASK
                    PIECE_PAWN -> generatePawnMoves(moveList, index, player)
                    PIECE_KNIGHT -> generateWalkerMoves(moveList, index, knight_move_offsets, player)
                    PIECE_BISHOP -> genSliderMoveOffsets(moveList, index, bishop_move_offsets, player)
                    PIECE_ROOK -> genSliderMoveOffsets(moveList, index, rook_move_offsets, player)
                    PIECE_QUEEN -> genSliderMoveOffsets(moveList, index, queen_move_offsets, player)
                    PIECE_KING -> genKingMoves(moveList, index, player)

fun generatePawnMoves(moveList:MoveList, index:Int, player:Int)
    val direction = if player=PIECE_WHITE then RANK_MULT else -RANK_MULT
    val startRank = if player=PIECE_WHITE then RANK_MULT else 6*RANK_MULT
   
    # Single square forward
    val forwardIndex = index + direction
    if (forwardIndex & INVALID_MASK) = 0 and board[forwardIndex] = 0
        moveList.addMove(index, forwardIndex)
        
    # Double square forward from starting position
    if (index&RANK_MASK) = startRank
        val doubleForwardIndex = index + 2*direction
        if board[forwardIndex] = 0 and board[doubleForwardIndex] = 0
            moveList.addMove(index, doubleForwardIndex)
    
    # Captures (including en-passant)
    val captureLeft = forwardIndex - 1
    if (captureLeft&INVALID_MASK) = 0
        if (board[captureLeft] != 0 and (board[captureLeft]&COLOR_MASK) != player)
            moveList.addMove(index, captureLeft)
        elsif captureLeft = enPassantSquare
            moveList.addEnPassantMove(index, captureLeft)        
    val captureRight = forwardIndex + 1
    if (captureRight&INVALID_MASK) = 0
        if (board[captureRight] != 0 and (board[captureRight]&COLOR_MASK) != player)
            moveList.addMove(index, captureRight)
        elsif captureRight = enPassantSquare
            moveList.addEnPassantMove(index, captureRight)

fun genKingMoves(moveList:MoveList, index:Int, player:Int)
    generateWalkerMoves(moveList, index, king_move_offsets, player)

    # Castling. Only add castling moves if the king is on its original square 
    # (index 4 for white, 116 for black), and the squares between the king and rook are empty. 
    if (player=0 and index=4) or (player=1 and index=116)
        # Kingside castling
        if (board[index+1]=0 and board[index+2]=0) and (board[index+3] = (PIECE_ROOK | player))
            moveList.addMove(index, index + 2)
        # Queenside castling
        if (board[index-1]=0 and board[index-2]=0 and board[index-3]=0) and (board[index-4] = (PIECE_ROOK | player))
            moveList.addMove(index, index - 2)

fun generateWalkerMoves(moveList:MoveList, startSquare:Int, offsets:Array<Int>, player:Int)
    for offset in offsets
        val targetIndex = startSquare + offset
        if (targetIndex & INVALID_MASK) = 0 and isEmptyOrOpponent(targetIndex, player)
            moveList.addMove(startSquare, targetIndex)

fun genSliderMoveOffsets(moveList:MoveList, startSquare:Int, offsets:Array<Int>, player:Int)
    for offset in offsets
        for i in 1..7
            val targetIndex = startSquare + offset*i
            if (targetIndex&INVALID_MASK)!=0
                break
            val targetPiece = board[targetIndex]
            if targetPiece=0
                moveList.addMove(startSquare, targetIndex)
            elsif (targetPiece&COLOR_MASK) != player
                moveList.addMove(startSquare, targetIndex)
                break
            else
                break

var kingCache = 0
fun findKing(player:Int) -> Int
    val king = PIECE_KING | player
    if board[kingCache] = king
        return kingCache
    for i in 0..<128
        if board[i]=king
            kingCache = i
            return i
    return -1  # Should never happen in a valid position


fun isInCheck(player:Int) -> Bool
    val kingSquare = findKing(player)
    val opponent = 1 - player
    return isSquareAttacked(kingSquare, opponent)


fun isSquareAttacked(square:Int, attackerColor:Int) -> Bool
    # Check for pawn attacks
    val pawnDirection = if attackerColor=PIECE_WHITE then -RANK_MULT else RANK_MULT
    val pawnAttackLeft = square + pawnDirection - 1
    if (pawnAttackLeft&INVALID_MASK) = 0 and board[pawnAttackLeft] = (PIECE_PAWN | attackerColor)
        return true
    val pawnAttackRight = square + pawnDirection + 1
    if (pawnAttackRight&INVALID_MASK) = 0 and board[pawnAttackRight] = (PIECE_PAWN | attackerColor)
        return true

    # Check for knight attacks
    for offset in knight_move_offsets
        val knightSquare = square + offset
        if (knightSquare&INVALID_MASK) = 0 and board[knightSquare] = (PIECE_KNIGHT | attackerColor)
            return true

    # Check for bishop/queen attacks
    for offset in bishop_move_offsets
        for i in 1..7
            val targetIndex = square + offset*i
            if (targetIndex&INVALID_MASK)!=0
                break
            val targetPiece = board[targetIndex]
            if targetPiece=0
                continue
            elsif targetPiece=(PIECE_BISHOP | attackerColor) or targetPiece=(PIECE_QUEEN | attackerColor)
                return true
            else
                break

    # Check for rook/queen attacks
    for offset in rook_move_offsets
        for i in 1..7
            val targetIndex = square + offset*i
            if (targetIndex&INVALID_MASK)!=0
                break
            val targetPiece = board[targetIndex]
            if targetPiece=0
                continue
            elsif targetPiece=(PIECE_ROOK | attackerColor) or targetPiece=(PIECE_QUEEN | attackerColor)
                return true
            else
                break

    # Check for king attacks
    for offset in king_move_offsets
        val sq = square + offset
        if (sq&INVALID_MASK) = 0 and board[sq] = (PIECE_KING | attackerColor)
            return true
    return false

fun generateLegalMoves(moveList:MoveList, player:Int)
    val ep = enPassantSquare
    val sc = score
    val hc = currentHash
    generatePseudoLegalMoves(moveList, player)
    for i in 0..<moveList.count
        makeMove(moveList.moves[i])
        val check = isInCheck(player)
        undoMove(moveList.moves[i])
        if check
            moveList.invalidateMove(i)  # Mark move as invalid if it leaves player in check
    enPassantSquare = ep
    score = sc
    currentHash = hc

# fun evaluate(player:Int, depth:Int)
#     val moveList = new MoveList()
#     val ep = enPassantSquare
#     generateLegalMoves(moveList, player)
#     if depth!=0
#         for i in 0..<moveList.count
#             if moveList.moves[i].from != -1
#                 makeMove(moveList.moves[i])
#                 evaluate(1-player, depth-1)
#                 undoMove(moveList.moves[i])
#                 enPassantSquare = ep
#     else
#         for i in 0..<moveList.count
#             if moveList.moves[i].from != -1
#                 totalMoves += 1
#     free(moveList)

fun showMovesWithScore(moveList:MoveList, player:Int)
    val ep = enPassantSquare
    val sc = score
    val hc = currentHash
    kprintf("Move list with scores: %d\n", score)
    for i in 0..<moveList.count
        if moveList.moves[i].from != -1
            kprintf("Move: ")
            moveList.printMove(i)
            makeMove(moveList.moves[i])
            val moveScore = alphabeta(1, 1 - player, -100000, 100000, 1)
            kprintf(" Score: %d\n", moveScore)
            undoMove(moveList.moves[i])
            enPassantSquare = ep
            score = sc
            currentHash = hc

fun orderMoves(moveList:MoveList, ply:Int)
    # Simple move ordering: captures first, then killers, then quiet moves
    # For now, just move killer moves to front
    for i in 0..<moveList.count
        if moveList.moves[i].from != -1
            val move = moveList.moves[i]
            if isKillerMove(move.from, move.to, ply)
                # Move killer to position i by swapping with first non-killer
                for j in 0..<i
                    val prevMove = moveList.moves[j]
                    if prevMove.from != -1 and not isKillerMove(prevMove.from, prevMove.to, ply)
                        moveList.swapMoves(i, j)
                        killerHits += 1
                        break

fun chooseBestMove(moveList:MoveList, player:Int) -> Int
    # Reset hash statistics for this move search
    resetHashStatistics()
    
    val ep = enPassantSquare
    val sc = score
    val hc = currentHash
    kprintf("Move list with scores: %d\n", score)
    
    # Check to see if there is a book move available in the opening book
    if useBook
        kprintf("Checking for book move... %d\n", player)
        val (book_from,book_to) = lookupOpeningMove(player,0xf)
        for i in 0..<moveList.count
            if moveList.moves[i].from = book_from and moveList.moves[i].to = book_to
                kprintf("Found book move: ")
                moveList.printMove(i)
                kprintf("\n")
                return i
    useBook = false  # No book move found, disable book for future moves in this game

    # First pass: Quick evaluation at depth 3 to order moves
    val moveScores = new Array<Int>(256)
    var bestMoveIndex = -1
    var bestScore = if player=PIECE_WHITE then -100000 else 100000
    
    # Iterative deepening: search at increasing depths, reusing TT results from previous iterations
    for currentDepth in 1..LEVEL
        kprintf("\n=== Iterative deepening: depth %d ===\n", currentDepth)
        
        # If we have a best move from the previous iteration, move it to the front for better pruning
        if bestMoveIndex > 0
            moveList.swapMoves(0, bestMoveIndex)
            val tempScore = moveScores[0]
            moveScores[0] = moveScores[bestMoveIndex]
            moveScores[bestMoveIndex] = tempScore
            bestMoveIndex = 0
        
        # Reset best move tracking for this depth
        bestScore = if player=PIECE_WHITE then -100000 else 100000
        bestMoveIndex = -1
        
        # Initialize alpha/beta window - will be narrowed as we find better moves
        var alpha = -100000
        var beta = 100000
        
        for i in 0..<moveList.count
            if moveList.moves[i].from != -1
                kprintf("Move: ")
                moveList.printMove(i)
                makeMove(moveList.moves[i])
                val moveScore = alphabeta(currentDepth, 1 - player, alpha, beta, 1)
                kprintf(" Score: %d\n", moveScore)
                moveScores[i] = moveScore
                
                if player=PIECE_WHITE and moveScore > bestScore
                    bestScore = moveScore
                    bestMoveIndex = i
                    alpha = bestScore  # Narrow the window - future moves must beat this
                if player=PIECE_BLACK and moveScore < bestScore
                    bestScore = moveScore
                    bestMoveIndex = i
                    beta = bestScore  # Narrow the window - future moves must beat this
                
                undoMove(moveList.moves[i])
                enPassantSquare = ep
                score = sc
                currentHash = hc
            else
                moveScores[i] = if player=PIECE_WHITE then -100000 else 100000
        
        kprintf("Best move at depth %d: index %d, score %d\n", currentDepth, bestMoveIndex, bestScore)
    
    # Print hash statistics for this move search
    printHashStatistics()
    
    free(moveScores)
    return bestMoveIndex


fun alphabeta(depth:Int, player:Int, alpha:Int, beta:Int, ply:Int) -> Int
    # Only record positions at depth >= 1 for statistics
    # (depth 0 positions are leaves - we've already computed their score, so no point caching)
    if depth >= 1
        recordPosition(currentHash)
        
        # Probe transposition table
        val ttScore = probeTranspositionTable(currentHash, depth, alpha, beta)
        if ttScore != -999999
            return ttScore
    
    # kprintf("Alphabeta depth %d, player %d, score %d\n", depth, player, score)
    # if depth=0
    #     return score

    val originalAlpha = alpha
    val moveList = new MoveList()
    val ep = enPassantSquare
    val sc = score
    val hc = currentHash
    generatePseudoLegalMoves(moveList, player)
    
    # Order moves: killers first for better pruning
    orderMoves(moveList, ply)
    
    var a = alpha
    var b = beta
    var bestScore = if player=PIECE_WHITE then -100000 else 100000
    
    for i in 0..<moveList.count
        if moveList.moves[i].from != -1
            val currentMove = moveList.moves[i]
            makeMove(currentMove)
            # val nextDepth = if depth=1 and currentMove.captured != 0 then 1 else depth - 1  # Quiescence search for captures at depth 1
            val nextDepth = depth - 1
            val eval = if nextDepth=0 then score else alphabeta(nextDepth, 1-player, a, b, ply+1)
            undoMove(currentMove)
            enPassantSquare = ep
            score = sc
            currentHash = hc
            
            if player=PIECE_WHITE
                if eval > bestScore
                    bestScore = eval
                if bestScore >= b
                    # Beta cutoff - store killer move if it's a quiet move
                    # if currentMove.captured = 0
                    storeKiller(currentMove.from, currentMove.to, ply)
                    free(moveList)
                    # Store in transposition table before returning
                    if depth >= 1
                        storeTranspositionTable(hc, bestScore, depth, originalAlpha, b)
                    return bestScore
                if bestScore > a
                    a = bestScore
            else
                if eval < bestScore
                    bestScore = eval
                if bestScore <= a
                    # Alpha cutoff - store killer move if it's a quiet move
                    # if currentMove.captured = 0
                    storeKiller(currentMove.from, currentMove.to, ply)
                    free(moveList)
                    # Store in transposition table before returning
                    if depth >= 1
                        storeTranspositionTable(hc, bestScore, depth, originalAlpha, b)
                    return bestScore
                if bestScore < b
                    b = bestScore
    
    free(moveList)
    
    # Store result in transposition table
    if depth >= 1
        storeTranspositionTable(hc, bestScore, depth, originalAlpha, beta)
    
    return bestScore


# function alphabeta(node, depth, α, β, maximizingPlayer) is
#     if depth == 0 or node is terminal then
#         return the heuristic value of node
#     if maximizingPlayer then
#         value := −∞
#         for each child of node do
#             value := max(value, alphabeta(child, depth − 1, α, β, FALSE))
#             if value ≥ β then
#                 break (* β cutoff *)
#             α := max(α, value)
#         return value
#     else
#         value := +∞
#         for each child of node do
#             value := min(value, alphabeta(child, depth − 1, α, β, TRUE))
#             if value ≤ α then
#                 break (* α cutoff *)
#             β := min(β, value)
#         return value