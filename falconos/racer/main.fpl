const SCREEN_WIDTH = 640
const SCREEN_HEIGHT = 480

const gameMap = const Array<Float> [
#   Length, Curvature,  Slope,  Width
    60.0,    0.0,      0.0,    10.0,
    100.0,   0.0,      0.0,    10.0,
    200.0,   0.01,     0.0,    10.0,
    100.0,   0.0,      0.0,    10.0,
    200.0,  -0.01,     0.0,    10.0,
    100.0,   0.0,      0.0,    10.0,
    300.0,   0.02,     0.0,    10.0,
    100.0,   0.0,      0.0,    20.0,
    200.0,  -0.02,     0.0,    20.0,
    100.0,   0.0,      0.0,    20.0,
    200.0,   0.0,      0.2,    10.0,
    40.0,    0.0,      0.0,    10.0,
    200.0,   0.0,     -0.2,    10.0 ]

const numGameMapEntries = 13
const MAP_LENGTH = 0
const MAP_CURVATURE = 1
const MAP_SLOPE = 2
const MAP_WIDTH = 3

# Workaround for now until we get better string handling
fun atos(n:Int) -> String
    var len = if n<10 then 1 else if n<100 then 2 else if n<1000 then 3 else 4
    var nn = n
    val ret = new Array<Char>(len+1)
    ret[len] = ' '
    while len>0
        len -= 1
        ret[len] = ((nn % 10) + 48) as Char
        nn = nn / 10
    return unsafe(ret as String)

const palette = const Array<Int> [
    0x000000, 0x9C9FDC, 0xD58B08, 0x179C91,
    0x505197, 0x54995C, 0x00E4A3, 0x945854,
    0xA59B19, 0xA2D400, 0xDED000, 0xD1E5E3,
    0x9CD49B, 0x895031, 0x009854, 0x00890D, 
    0x9EA75E, 0x6F9C11, 0x572515, 0x73CF5F, 
    0xABCBCD, 0xCC739F, 0xA4989E, 0xE4A2A5, 
    0x00F2EE, 0x6F9E90, 0x494400, 0xDAD8A2, 
    0x115221, 0x0C1448, 0x6B63D8, 0x73A5D6, 
    0x66F3B5, 0xEA055D, 0xC66300, 0x00C663, 
    0x14171A, 0x8A00A1, 0x00B5D6, 0x006994, 
    0x5E4262, 0x135265, 0xE700E7, 0xAA03EF, 
    0xE7ACE9, 0x00D600, 0xA5C673, 0xC600A5, 
    0x947394, 0xF75B5B, 0x84116D, 0x951911, 
    0x0063F7, 0x8463C6, 0x003000, 0x004000, 
    0xF6F7F4, 0xE7E7EA, 0x737371, 0xD6D6D4, 
    0xB4B5B4, 0x8D8484, 0x00C6E7, 0xB3A593, 
    0x00D6E7, 0xA89485, 0xD2C6B3, 0xCEC6EF, 
    0x929490, 0xC65252, 0xA7A5A9, 0xF00000, 
    0xD6D6E7, 0xC6B5A5, 0xC6C6C8, 0xF0D6B1, 
    0x00E7E7, 0xE7D6F7, 0x009400, 0xA50052, 
    0x850000, 0x8F846A, 0x632108, 0xE76363, 
    0xF5C684, 0xA53131, 0xEFE7CE, 0x6C6342, 
    0x645200, 0x000093, 0xF79484, 0xD58485, 
    0xD66363, 0xF7F794, 0x424242, 0xC90000, 
    0xCEC68F, 0x00B5E7, 0xD6F784, 0xC8A573, 
    0x646364, 0x000072, 0xEDC6A7, 0xF7F773, 
    0xB5C6B4, 0xD5A5A5, 0xB09472, 0x4AB542, 
    0x006300, 0x84F700, 0xE8D6C6, 0xE7B58D, 
    0xF5E7AE, 0xCEA58E, 0x7394A7, 0x6D4200, 
    0x867300, 0x007309, 0x844200, 0xCAB500, 
    0xD0B592, 0xACA500, 0xE7B572, 0xA90000, 
    0x8E6300, 0xF7A5A7, 0x00948F, 0xA9940A, 
    0x525230, 0xF3F700, 0x698400, 0x946331, 
    0x525252, 0x8F5269, 0xB5E773, 0x429410, 
    0x005200, 0xB500D6, 0x6C84AB, 0x8FB5B1, 
    0xA56321, 0xCE948F, 0x52C6C6, 0x424221, 
    0xAA8400, 0xD6A5CC, 0x949473, 0x73B500, 
    0xACB5EE, 0x8BC6C6, 0x737352, 0x0000CE, 
    0xD2F7EE, 0xF7F7D3, 0x0000E7, 0xF3E700, 
    0x94A5B5, 0xF7D694, 0xA56300, 0xEFA58B, 
    0xB5B5C6, 0x219421, 0x03B500, 0x8473B5, 
    0xD4E7C7, 0x00E700, 0x675225, 0x719472, 
    0x737391, 0xD2A500, 0x84E7C6, 0xB57384, 
    0xD6D691, 0x633100, 0xC6C621, 0xA9B594, 
    0x006352, 0x426300, 0x7373B5, 0x877365, 
    0x314242, 0x52C6A5, 0x63F7D6, 0x731000, 
    0xB46352, 0x003100, 0x84C652, 0xB5B500, 
    0x00C600, 0x421000, 0xAE8484, 0x63A500, 
    0x0052A5, 0x293131, 0xD5C673, 0xC67342, 
    0x0094E7, 0xB5F7E8, 0x0084F7, 0x426373, 
    0xC631B5, 0x429442, 0x94C6B5, 0x8473D6, 
    0x927349, 0x63D600, 0xD684C6, 0x8C94C8, 
    0x0063B5, 0xC8C600, 0xE7B500, 0x00F700, 
    0x0094C6, 0x0042B5, 0xC6846F, 0x85B563, 
    0x879400, 0x686300, 0xD2B5D6, 0x0094AD, 
    0xA5C68B, 0xA52194, 0x212173, 0x528452, 
    0x528400, 0xA78473, 0xAA7300, 0xF3F7B1, 
    0x9494A9, 0xB4C6E7, 0x67524C, 0xF47300, 
    0xF70084, 0xA6D6C7, 0x739484, 0xB5F7B5, 
    0xD67363, 0x00B573, 0xAE6364, 0x7384D6, 
    0x73B594, 0xD36386, 0x8484A7, 0xD37300, 
    0x316300, 0x0000B5, 0x844273, 0x526352, 
    0x211042, 0xB5638F, 0x945200, 0x008494, 
    0x94D6A5, 0xF70031, 0x73C6A5, 0xD65263]

fun loadImageFromFile(filename:String, width:Int, height:Int) -> Image
    val data = readFile(filename)
    if data is Error
        kprintf("Error loading image file %s\n", filename)
        abort(1)
    return new Image(width, height, data)

const SPRITE_CAR_STRAIGHT = 0
const SPRITE_CAR_DOWN = 1
const SPRITE_CAR_UP = 2
const SPRITE_CAR_TURN = 3
const SPRITE_CAR_DOWNTURN = 4
const SPRITE_CAR_UPTURN = 5
const SPRITE_CAR_TURN2 = 6
const SPRITE_SMOKE1 = 7
const SPRITE_SMOKE2 = 8
const SPRITE_SMOKE3 = 9
const SPRITE_SMOKE4 = 10
const SPRITE_DANKE = 11
const SPRITE_PALM = 12
const SPRITE_START_L = 13
const SPRITE_START_R = 14
const SPRITE_SLOW_DOWN = 15

fun loadSprites() -> Array<Image>
    val spriteArray = new Array<Image>(20)
    spriteArray[SPRITE_CAR_STRAIGHT] = loadImageFromFile("sprites/car_straight.bin", 88, 41)
    spriteArray[SPRITE_CAR_DOWN]     = loadImageFromFile("sprites/car_down.bin", 88, 41)
    spriteArray[SPRITE_CAR_UP]       = loadImageFromFile("sprites/car_up.bin", 88, 41)
    spriteArray[SPRITE_CAR_TURN]     = loadImageFromFile("sprites/car_turn.bin", 88, 41)
    spriteArray[SPRITE_CAR_DOWNTURN] = loadImageFromFile("sprites/car_downturn.bin", 88, 41)
    spriteArray[SPRITE_CAR_UPTURN]   = loadImageFromFile("sprites/car_upturn.bin", 88, 41)
    spriteArray[SPRITE_CAR_TURN2] = loadImageFromFile("sprites/car_turn2.bin", 88, 41)
    spriteArray[SPRITE_SMOKE1] = loadImageFromFile("sprites/smoke1.bin", 40, 25)
    spriteArray[SPRITE_SMOKE2] = loadImageFromFile("sprites/smoke2.bin", 40, 29)
    spriteArray[SPRITE_SMOKE3] = loadImageFromFile("sprites/smoke3.bin", 24, 20)
    spriteArray[SPRITE_SMOKE4] = loadImageFromFile("sprites/smoke4.bin", 24, 13)
    spriteArray[SPRITE_DANKE] = loadImageFromFile("sprites/danke.bin", 120, 73)
    spriteArray[SPRITE_PALM] = loadImageFromFile("sprites/palm_tree.bin", 88, 168)
    spriteArray[SPRITE_START_L] = loadImageFromFile("sprites/start_left.bin", 240, 61)
    spriteArray[SPRITE_START_R] = loadImageFromFile("sprites/start_right.bin", 240, 61)
    spriteArray[SPRITE_SLOW_DOWN] = loadImageFromFile("sprites/slow_down.bin", 64, 112)
    return spriteArray

class RoadObject(val z:Float, val x:Float, val y: Float, val spriteIndex:Int)

class DrawSpriteParams(val image:Image, val screenX:Int, val thisScreenY:Int, val scale:Float)


class Game(val gc:GraphicsContext, val kb:Keyboard)
    val screenCenterX = 320.0
    val screenCenterY = 240.0
    val focalLength = 250.0
    val cameraY = 5.0
    val cameraZ = -1.0
    val stripeLength = 1.0
    var carX = 0.0      # car position relative to center of road
    var cameraTilt = 0.0
    var carTurning = 0

    var sprites : Array<Image>
    var roadObjects : Array<List<RoadObject>>
    
    var currentMapIndex = 0
    var distanceIntoSegment = 0.0
    var speed = 0.0         # speed along the road
    var smokeCounter = 0
    var doubleBufferPhase = 0


    val scanZ = new Array<Float>(480)              # Z distance for each screen row
    val roadWidthOnScreen = new Array<Float>(480)  # Road width in pixels for each screen row
    val roadCenter = new Array<Float>(480)         # Road center X position for each screen row
    val drawSprites = new List<DrawSpriteParams>() # Sprites to draw this frame
    var horizonRow = 480                           # Row number of horizonRow
    
    var printCounter = 0

    fun createRoadObject() 
        roadObjects = new Array<List<RoadObject>>(numGameMapEntries) {new List<RoadObject>() }
        roadObjects[0].add(new RoadObject(50.0, -17.5, 3.0, SPRITE_START_L)) 
        roadObjects[0].add(new RoadObject(50.0,  17.5, 3.0, SPRITE_START_R)) 
        roadObjects[1].add(new RoadObject(10.0, -15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(10.0,  15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(30.0, -15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(30.0,  15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(50.0, -15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(50.0,  15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(70.0, -15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(70.0,  15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(90.0, -15.0, 0.0, SPRITE_PALM)) 
        roadObjects[1].add(new RoadObject(90.0,  15.0, 0.0, SPRITE_PALM)) 
        roadObjects[3].add(new RoadObject(50.0, -15.0, 0.0, SPRITE_DANKE))
        roadObjects[5].add(new RoadObject(50.0, -15.0, 0.0, SPRITE_SLOW_DOWN))

    fun updateRoadPosition()
        # Determine which segment we are in
        distanceIntoSegment = distanceIntoSegment + speed*0.1
        while distanceIntoSegment > gameMap[currentMapIndex*4+MAP_LENGTH]
            distanceIntoSegment = distanceIntoSegment - gameMap[currentMapIndex*4+MAP_LENGTH]
            currentMapIndex = (currentMapIndex + 1) % numGameMapEntries

        kb.getKey()
        carX = carX + 0.0006 * speed * carTurning

        if kb.keyDown[KEY_SCANCODE_LEFT]
            if carTurning<40
                carTurning += 2
        elsif kb.keyDown[KEY_SCANCODE_RIGHT]
            if carTurning>-40
                carTurning -= 2

        if carTurning>0
            carTurning -= 1
        else if carTurning<0
            carTurning += 1

        if kb.keyDown[KEY_SCANCODE_UP]
            speed = speed + (if speed<5.0 then 0.04 else if speed<10.0 then 0.02 else 0.01)
        if kb.keyDown[KEY_SCANCODE_DOWN]
            speed =speed - 0.03
        carX = carX + gameMap[currentMapIndex*4+MAP_CURVATURE] * speed * speed * 0.2
        val roadWidth = gameMap[currentMapIndex*4+MAP_WIDTH]
        if (carX > roadWidth/2.0 or carX < -roadWidth/2.0) and speed>2.0
            speed = speed - 0.05
        if speed<0.0
            speed = 0.0
        if carX > 20.0
            carX = 20.0 
        if carX < -20.0
            carX = -20.0
        cameraTilt = cameraTilt*0.95 + gameMap[currentMapIndex*4+MAP_SLOPE] * 0.05



    fun calculateScene()
        var currentOffset = 0.0
        var currentCurve = 0.0
        var currentHeight = 0.0

        for i in 0..<=479
            scanZ[i] = 0.0

        # walk along the road in Z
        var z = 0.1
        var dz = 0.5
        var distance = distanceIntoSegment
        var index = currentMapIndex
        horizonRow = SCREEN_HEIGHT        # Check that we haven't occluded everything
        var objectIndex = 0

        drawSprites.clear()
        while objectIndex < roadObjects[index].length and roadObjects[index].get(objectIndex).z < distanceIntoSegment
            objectIndex = objectIndex + 1

        var prevScreenY = SCREEN_HEIGHT
        var prevRoadCenterX = screenCenterX
        var prevRoadWidth = 640.0
        var prevZ = 0.0

        while z < 200.0
            # get road parameters for current segment
            while distance > gameMap[index*4+MAP_LENGTH]
                distance = distance - gameMap[index*4+MAP_LENGTH]   # distance into next segment
                index = (index + 1) % numGameMapEntries
                objectIndex = 0

            # calculate curvature and height
            currentCurve = currentCurve + gameMap[index*4+MAP_CURVATURE] * dz
            currentOffset = currentOffset + currentCurve * dz
            currentHeight = currentHeight  + gameMap[index*4+MAP_SLOPE] * dz

            # project road segment at distance z onto screen
            val thisScreenY = (screenCenterY - focalLength * (currentHeight-cameraY-cameraTilt*z) / (z - cameraZ)) as Int
            val scale = focalLength / z
            val thisRoadCenter = screenCenterX + (carX + currentOffset) * scale
            val thisRoadWidth = gameMap[index*4+MAP_WIDTH] * scale
            # kprintf("Z: %f ScreenY: %d RoadCenter: %f RoadWidth: %f\n", z, thisScreenY, thisRoadCenter, thisRoadWidth)

            # only draw if we are on screen and haven't already drawn something closer
            # kprintf("Z: %f ScreenY: %d\n", z, thisScreenY)
            if thisScreenY<horizonRow 
                # Interpolate from last row to this row
                val numRows = prevScreenY - thisScreenY
                # kprintf("Interpolating %d rows from %d to %d\n", numRows, prevScreenY, thisScreenY)
                for iy in 1..<=numRows
                    val interpY = prevScreenY - iy
                    if interpY>0 and interpY<480
                        # kprintf("  Row %d\n", interpY)
                        val t = (iy as Float) / (numRows as Float)
                        val interpCenter = prevRoadCenterX + t * (thisRoadCenter - prevRoadCenterX)
                        val interpWidth = prevRoadWidth + t * (thisRoadWidth - prevRoadWidth)
                        scanZ[interpY] = prevZ + t * (z - prevZ)
                        roadCenter[interpY] = interpCenter
                        roadWidthOnScreen[interpY] = interpWidth
                        # kprintf("    interpY: %d t: %f center: %f width: %f\n", interpY, t, interpCenter, interpWidth)
                horizonRow = thisScreenY
                
                # check for road objects to draw at this Z distance
                while objectIndex < roadObjects[index].length and roadObjects[index].get(objectIndex).z < distance
                    val obj = roadObjects[index].get(objectIndex)
                    val objRelDistance = obj.z - distance  # Distance relative to current drawing position on road
                    val intp = (objRelDistance / (z - prevZ))     # interpolation factor between previous and current row
                    val objScale = focalLength / (objRelDistance + z)
                    val objScreenY = (thisScreenY + intp * (thisScreenY - prevScreenY)) as Int
                    val intRoadCenterX = thisRoadCenter + intp * (thisRoadCenter - prevRoadCenterX)
                    val objScreenX = (intRoadCenterX + obj.x * objScale) as Int

                    drawSprites.add(new DrawSpriteParams(sprites[obj.spriteIndex], objScreenX, objScreenY, objScale*0.15))
                    objectIndex = objectIndex + 1


            prevRoadCenterX = thisRoadCenter
            prevRoadWidth = thisRoadWidth
            prevScreenY = thisScreenY
            prevZ = z


            z = z + dz
            distance = distance + dz
            dz = dz * 1.1

    fun drawFrame()
        # lastRow now contains the screen coordinate of the horizonRow
        gc.drawRect(0, 0, SCREEN_WIDTH, horizonRow, 0x1F)  # sky


        # add speedometer
        val speedStr = atos((speed * 10.0) as Int)
        gc.drawText(280, 10, 0, 10, "Speed ")
        gc.drawText(340, 10, 0, 10, speedStr)
        free speedStr

        hwregs.ledr = 0
        # draw the road
        # kprintf("Drawing road from row %d to %d\n", horizonRow, SCREEN_HEIGHT-1)
        for y in horizonRow..<SCREEN_HEIGHT
            val x = roadCenter[y] as Int
            val halfWidth = (roadWidthOnScreen[y] / 2.0) as Int
            val startX = x - halfWidth
            val endX = x + halfWidth
            # kprintf("Row %d: road center %d width %d startX %d endX %d\n", y, x, halfWidth*2, startX, endX)
            # hwregs.ledr = 6
            if startX>=SCREEN_WIDTH or endX<=0
                # hwregs.ledr = 3
                gc.drawRect(0, y, SCREEN_WIDTH, y+1, 0x0F) # all grass
                # hwregs.ledr = 4
                continue

            # hwregs.ledr = 5

            val roadStripe = (((distanceIntoSegment + scanZ[y]) / stripeLength) as Int) % 8

            if (startX<0 and endX>SCREEN_WIDTH) # all road
                gc.drawRect(0, y, SCREEN_WIDTH, y+1, 0x24)
            else if endX>=0 and startX<SCREEN_WIDTH # partial road
                val startXClipped = if startX<0 then 0 else startX
                val endXClipped = if endX>SCREEN_WIDTH then SCREEN_WIDTH else endX
                gc.drawRect(0, y, startXClipped, y+1, 0x0F)
                gc.drawRect(startXClipped, y, endXClipped, y+1, 0x24) # road
                gc.drawRect(endXClipped, y, SCREEN_WIDTH, y+1, 0x0F)

            val stripeWidth = (roadWidthOnScreen[y] / 40.0) as Int
            # draw curbs
            val curbColor = if (roadStripe&2)=0 then 0x38 else 0x47
            gc.drawRect(startX, y, startX + stripeWidth, y+1, curbColor)
            gc.drawRect(endX - stripeWidth, y, endX, y+1, curbColor)

            if roadStripe<4
                # draw road stripe
                val stripeStartX = x - (stripeWidth / 2)
                val stripeEndX = stripeStartX + stripeWidth
                if stripeEndX>=0 and stripeStartX<SCREEN_WIDTH
                    gc.drawRect(stripeStartX, y, stripeEndX, y+1, 0x38)

        # draw road objects
        for index in drawSprites.length-1..>=0
            val ds = drawSprites.get(index)
            val spriteWidth = (ds.image.width * ds.scale) as Int
            val spriteHeight = (ds.image.height * ds.scale) as Int
            val drawX = ds.screenX - (spriteWidth / 2)
            val drawY = ds.thisScreenY - spriteHeight
            # kprintf("Drawing sprite at %d,%d scale %f\n", drawX, drawY, ds.scale)
            if ds.scale<4.0 and ds.scale>-4.0
                gc.drawImage(drawX, drawY, ds.image, ds.scale, ds.scale)
            free ds

        # draw the car sprite
        val sprite : Image
        if cameraTilt > 0.02
            if carTurning>10 or carTurning<-10
                sprite = sprites[SPRITE_CAR_UPTURN]
            else
                sprite = sprites[SPRITE_CAR_UP]
        elsif cameraTilt < -0.02
            if carTurning>10 or carTurning<-10
                sprite = sprites[SPRITE_CAR_DOWNTURN]
            else
                sprite = sprites[SPRITE_CAR_DOWN]
        else
            if carTurning>10 or carTurning<-10
                sprite = sprites[SPRITE_CAR_TURN2]
            else if carTurning!=0
                sprite = sprites[SPRITE_CAR_TURN]
            else
                sprite = sprites[SPRITE_CAR_STRAIGHT]

        if carTurning<0
            gc.drawImage(320-44,410,sprite,1.0,1.0)
        else
            gc.drawImage(320-44,410,sprite, -1.0, 1.0)

        val roadWidth = gameMap[currentMapIndex*4+MAP_WIDTH] / 2.0
        if (carX<-roadWidth+0.8 or carX>roadWidth-0.8)
            smokeCounter = smokeCounter + 1
            if smokeCounter>=12
                smokeCounter = 0
            if carX>0.0 or carX<-roadWidth-0.8
                gc.drawImage(268,432,sprites[SPRITE_SMOKE4-smokeCounter/3],1.0,1.0) # left side
            if carX<0.0 or carX>roadWidth+0.8
                gc.drawImage(342,432,sprites[SPRITE_SMOKE4-smokeCounter/3],-1.0,1.0) # right side
        else
            smokeCounter = 0
    end fun

fun drawPallette(gc:GraphicsContext)
    gc.drawRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0)  # black background
    for i in 0..<=255
        val x = (i % 16) * 40
        val y = (i / 16) * 30
        gc.drawRect(x, y, x+38, y+28, i)

fun main()
    copyFontData()
    val gc = new GraphicsContext()
    gc.setup()
    gc.setTransparentColor(0)  # Set transparency color to palette index 0

    val screenBuffer1 = unsafe(new Array<Char>(640*480) as Int)
    val screenBuffer2 = unsafe(new Array<Char>(640*480) as Int)

    val kb = new Keyboard()

    val game = new Game(gc, kb)

    game.sprites = loadSprites()
    game.createRoadObject()

    val paletteRegs = unsafe(0xE0001000 as Pointer<Int>)
    for i in 0..<=255
        paletteRegs[i] = palette[i]

    while true
        # Wait for vertical blank
        # hwregs.seven_seg = hwregs.vga_pos
        while hwregs.vga_pos > 400
            kprintf("")
        while hwregs.vga_pos < 400
            kprintf("")

        if game.doubleBufferPhase=0
            gc.setGraphicsBuffer(screenBuffer1)
            hwregsVideo.addr = screenBuffer2
            game.doubleBufferPhase = 1
        else
            gc.setGraphicsBuffer(screenBuffer2)
            hwregsVideo.addr = screenBuffer1
            game.doubleBufferPhase = 0
        gc.setTransparentColor(0)  # Set transparency color to palette index 0

        # drawPallette(gc)
        game.updateRoadPosition()
        game.calculateScene()
        game.drawFrame()
        hwregs.seven_seg = hwregs.vga_pos