const SCREEN_WIDTH = 640
const SCREEN_HEIGHT = 480

var game: Game

struct PathElement(startPos:Float, endPos:Float, curvature:Float, slope:Float)
struct PathWidth(startPos:Float, width:Float, changeDist:Float)
struct SceneryObject(pos:Float, x:Float, y:Float, type:Int, pal:Int, props:Int)

# Workaround for now until we get better string handling
fun atos(n:Int) -> String
    var len = if n<10 then 1 else if n<100 then 2 else if n<1000 then 3 else 4
    var nn = n
    val ret = new Array<Char>(len+1)
    ret[len] = ' '
    while len>0
        len -= 1
        ret[len] = ((nn % 10) + 48) as Char
        nn = nn / 10
    return unsafe(ret as String)

const levelNames = const Array<String> [
    "Coconut Beach",
    "Devil's Canyon",
    "Gateway",
    "Cloudy Mountain",
    "Alps",
    "Desert",
    "Seaside Town",
    "Wheat Field",
    "Old Capital",
    "Wilderness",
    "Lakeside",
    "Autobahn",
    "Desolation Hill",
    "Death Valley",
    "Vineyard" ]

fun dumpPathElements(elements:Array<PathElement>, widths:Array<PathWidth>, scenery:Array<SceneryObject>)
    for i in elements
        kprintf("Element %f-%f curvature=%f slope=%f\n", i.startPos, i.endPos, i.curvature, i.slope)
    for i in widths
        kprintf("Width %f width=%f changeDist=%f\n", i.startPos, i.width, i.changeDist) 
    # for i in scenery
    #     kprintf("Scenery pos=%f x=%f y=%f type=%d pal=%d props=%d\n", i.pos, i.x, i.y, i.type, i.pal, i.props)
    kprintf("Total scenery objects: %d\n", scenery.length)


class NpcVehicle(var x:Float, var z:Float, var spriteIndex:Int, var maxSpeed:Float, var dx:Float)
    var speed = 0.0
    var laps = 0
    var collisionCounter = 0       # frames remaining of collision effect

    fun move()
        # kprintf("NPC vehicle at x=%f z=%f speed=%f\n", npc.x, npc.z, npc.speed)
        # accelerate to max speed
        if game.startTimer>0
            return  
        val (curve,slope) = game.getPathCurvature(z)
        val absCurve = if curve<0.0 then -curve else curve
        val localMaxSpeed = maxSpeed - (absCurve * 40.0) 
        
        if speed<localMaxSpeed
            speed = speed + (if speed<50.0 then 0.6 else if speed<100.0 then 0.3 else 0.1)
        elsif speed>localMaxSpeed
            speed = speed - 0.6

        z = z + speed * 0.002
        if z>game.totalPathDistance
            z = z - game.totalPathDistance
            laps = laps + 1

        x = x + dx
        val roadWidth = game.getPathWidth(z)
        # kprintf("NPC vehicle at z=%f has road width %f\n", z, roadWidth)
        # normal roads have edges at -5 and +5*numLanes
        # However dual-carriageways have a central reservation, which means they have edges at 0,10 and 15,25

        if (roadWidth<=7.0)
            if x>3*roadWidth-5
                dx = -0.1
            if x<-10.0 
                dx = 0.1
        else
            if (x>12.5 and x<14.5) or x>35.0
                dx = -0.1
            if x<2.5 or (x>23.0 and x<25.0)
                dx = 0.1

const COPPER_HALT    = 0x00000000
const COPPER_WAIT_EQ = 0x01000000
const COPPER_WRITE   = 0x02000000
const COPPER_WAIT_GE = 0x01000000

fun createCopperList() -> List<Int>
    val copperList = new List<Int>()

    const SKY_COLOR_INDEX = 0
    const PALETTE_REGISTER = 0x1000


    for i in 0..480
        val color = 0
        copperList.add(COPPER_WRITE | PALETTE_REGISTER | (SKY_COLOR_INDEX lsl 2))
        copperList.add(color)
        copperList.add(COPPER_WAIT_EQ | (i lsl 10) | 640)  # Wait until end of scanline

    copperList.add(COPPER_HALT)
    return copperList

fun setCopperList(copperList:List<Int>, cameraTilt:Float)
    const SKY_COLOR_INDEX = 0x1f
    const PALETTE_REGISTER = 0x1000

    val pal_index = 32 * level_palette[3*game.level + 2]   # sky palette index
    for i in 0..460
        # normalized height 0..1 (0 = bottom, 1 = top)
        if i=game.horizonRow
            break
        val t1 = 1.0 - i / 240.0 + (cameraTilt * 0.2)
        val t = if t1<0.0 then 0.0 else if t1>0.99 then 0.99 else t1
        val index = (t*32) as Int
        val color = skyPalettes[pal_index + index]
        copperList.set(i*3+1, color)



class Game(val gc:GraphicsContext, val kb:Keyboard, val audio:AudioSamples)
    val screenCenterX = 320.0
    val screenCenterY = 240.0
    var focalLength = 40.0
    val cameraY = 3.0
    var cameraZ = 0.2
    val stripeLength = 0.6
    var carX = 0.0      # car position relative to center of road
    var carZ = 0.0      # car position along the road
    var cameraTilt = 0.0
    var carTurning = 0
    var level = 0
    var allGameMap : Array<Array<PathElement>>
    var allWidthMap : Array<Array<PathWidth>>
    var allSlopeMap : Array<Array<Float>>
    var allScenery: Array<Array<SceneryObject>>
    var gameMap : Array<PathElement>
    var widthMap : Array<PathWidth>
    var slopeMap : Array<Float>
    var scenery : Array<SceneryObject>

    var sprites : Array<Image>
    var backgroundImage : Array<Image>
    
    var speed = 0.0         # speed along the road
    var smokeCounter = 0
    var doubleBufferPhase = 0
    var totalPathDistance = 0.0
    var flipState = 0    # 0= normal, 1=spinning, 2=flipping
    var flipCounter = 0
    var leftWheelOffRoad = false
    var rightWheelOffRoad = false
    var laps = 0
    var lastBreak = false
    var gear = 1
    var engineVol = 64
    var backgroundOffset = new Array<Float>(2)
    var startTimer = 200
    var rank = 1
    var score = 0

    val scanZ = new Array<Float>(480)              # Z distance for each screen row
    val roadWidthOnScreen = new Array<Float>(480)  # Road width in pixels for each screen row
    val roadCenter = new Array<Float>(480)         # Road center X position for each screen row
    var horizonRow = 480                           # Row number of horizonRow
    
    val roadX = new Array<Float>(256)      # Compute road world coordinates as function of Z
    val roadY = new Array<Float>(256)      # Compute road world coordinates as function of Z
    val roadWidth = new Array<Float>(256)  # Compute road width as function of Z
    val occlusionY = new Array<Int>(256)   # Occlusion Y for each road Z position

    val screenBuffer1 = unsafe(new Array<Char>(640*480) as Int)
    val screenBuffer2 = unsafe(new Array<Char>(640*480) as Int)
    val npcVehicles = new List<NpcVehicle>()

    var copperList : List<Int>

    fun loadGameMap(filename:String)
        val file = readFile(filename)
        if file is Error
            kprintf("Error loading path elements file %s\n", filename)
            abort(1)
        var address = unsafe(file as Int)
        allGameMap = new Array<Array<PathElement>>(18)
        allWidthMap = new Array<Array<PathWidth>>(18)
        allScenery = new Array<Array<SceneryObject>>(18)
        allSlopeMap = new Array<Array<Float>>(18)
        for level in 0..17
            kprintf("Loading level %d path data from address %x\n", level, address)
            allGameMap[level] = unsafe((address)+4) as Array<PathElement> # First 4 bytes in file are length, then the array
            address += 4 + (allGameMap[level].length * 16)
            kprintf("Loading width map for level %d from address %x\n", level, address)
            allWidthMap[level] = unsafe((address + 4) as Array<PathWidth>)
            address += 4 + (allWidthMap[level].length * 12)
            kprintf("Loading scenery for level %d from address %x\n", level, address)
            allScenery[level] = unsafe((address + 4) as Array<SceneryObject>)
            address += 4 + (allScenery[level].length * 24)
            kprintf("Loading slope map for level %d from address %x\n", level, address)
            allSlopeMap[level] = unsafe((address + 4) as Array<Float>)
            address += 4 + (allSlopeMap[level].length * 4)
        kprintf("Finished loading path data %x\n",allGameMap[0])
        totalPathDistance = allGameMap[0][allGameMap[0].length-1].endPos

    var printCounter = 0


    var currentCurveIndex = 0
    fun getPathCurvature(distance:Float) -> (Float,Float)
        val dist = if distance>totalPathDistance then distance - totalPathDistance else distance
        if (dist<gameMap[currentCurveIndex].startPos)
            currentCurveIndex = 0
        while dist>gameMap[currentCurveIndex].endPos and currentCurveIndex<gameMap.length-1
            currentCurveIndex += 1
        return (gameMap[currentCurveIndex].curvature, slopeMap[(distance as Int)%slopeMap.length])


    var currentWidthIndex = 0
    fun getPathWidth(distance:Float) -> Float
        val dist = if distance>totalPathDistance then distance - totalPathDistance else distance
        if (dist<widthMap[currentWidthIndex].startPos)
            currentWidthIndex = 0
        while currentWidthIndex!=widthMap.length-1 and dist>=widthMap[currentWidthIndex+1].startPos
            currentWidthIndex += 1
        val distIntoSegment = dist - widthMap[currentWidthIndex].startPos
        val changeDist = widthMap[currentWidthIndex].changeDist
        val thisWidth = widthMap[currentWidthIndex].width
        if distIntoSegment<changeDist
            val prevWidth = widthMap[currentWidthIndex-1].width
            val widthChange = thisWidth - prevWidth
            val width = prevWidth + (widthChange * (distIntoSegment / changeDist))
            # kprintf("Width at distance %f is %f (segment=%d distIntoSegment=%f prev=%f this=%f changeDist %f)\n", distance, width, currentWidthIndex, distIntoSegment, prevWidth, thisWidth,  changeDist)
            return width
        else
            return thisWidth


    fun updateCarPosition()
        if startTimer=100
            audio.beepBeepBeep.play()
        if startTimer>0
            return

        val key = kb.getKey()
        val (curve, slope) = getPathCurvature(carZ)
        val distanceTravelled = speed * 0.002   # Convert km/h into m/frame
        val dx = curve * distanceTravelled * distanceTravelled
        carX = carX + 5 * dx
        backgroundOffset[0] = backgroundOffset[0] + curve * distanceTravelled * 24.0
        backgroundOffset[1] = backgroundOffset[1] + curve * distanceTravelled * 32.0
        for i in 0..1
            if backgroundOffset[i]<0.0
                backgroundOffset[i] = backgroundOffset[i] + backgroundImage[i].width
            if backgroundOffset[i]> (backgroundImage[i].width as Float)
                backgroundOffset[i] = backgroundOffset[i] - backgroundImage[0].width

        val grip = if speed<20.0 then 0.00012 else 0.00006
        carX = carX + grip * speed * carTurning
        carZ = carZ + distanceTravelled
        if carZ>totalPathDistance
            carZ = carZ - totalPathDistance
            laps = laps + 1
            audio.checkpoint.play()
            if laps=2
                selectLevel(level + 1)

        if flipState=0
            if kb.keyDown[KEY_SCANCODE_LEFT]
                if carTurning<40
                    carTurning += 2
            elsif kb.keyDown[KEY_SCANCODE_RIGHT]
                if carTurning>-40
                    carTurning -= 2

        if carTurning>0
            carTurning -= 1
        else if carTurning<0
            carTurning += 1

        if speed>0.1
            speed = speed - 0.1

        if flipState!=0
            speed = speed - 0.6
        elsif kb.keyDown[KEY_SCANCODE_SPACE]
            speed = speed + (if speed<50.0 then 0.6 else if speed<100.0 then 0.4 else 0.2)
        elsif kb.keyDown[KEY_SCANCODE_B]
            speed =speed - 0.6
            if not lastBreak and speed>150.0
                audio.squeel.play()
        
        lastBreak = kb.keyDown[KEY_SCANCODE_B]

        # Check for off road
        val roadWidth = roadWidth[0]
        val (roadLeftEdge, roadRightEdge) = calcRoadEdges(carX, roadWidth)
        if roadLeftEdge>-0.7  or roadRightEdge<-1.1
            leftWheelOffRoad = true
        else
            leftWheelOffRoad = false
        if roadRightEdge<0.7 or roadLeftEdge>1.1
            rightWheelOffRoad = true
        else
            rightWheelOffRoad = false

        if (leftWheelOffRoad or rightWheelOffRoad) and speed>30.0
            speed = speed - 0.5
        if speed<0.0
            speed = 0.0
        if carX > 20.0
            carX = 20.0 
        if carX < -60.0
            carX = -60.0


        if kb.keyDown[KEY_SCANCODE_SPACE]
            if engineVol<128 then engineVol += 1
        else
            if engineVol>64 then engineVol -= 1

        if gear=1 and speed>60.0   then gear = 2
        if gear=2 and speed>100.0  then gear = 3
        if speed>150.0             then gear = 4
        if gear=4 and speed<140.0  then gear = 3
        if gear=3 and speed<90.0   then gear = 2
        if speed<40.0              then gear = 1

        val mult = if gear=1 then 300 else if gear=2 then 200 else if gear=3 then 150 else 125
        hwregsAudio[1].pitch = 0x2000 + ((speed as Int) * mult)
        hwregsAudio[1].volume = engineVol + (engineVol lsl 16)

    fun calcRoadCoords()
        # Calculate road world coordinates for each Z distance (in steps of 0.2)
        var x = carX
        var dx = 0.0
        var y = 0.0
        var z = carZ
        var section = 0
        while z>gameMap[section].endPos and section<gameMap.length-1
            section += 1

        for i in 0..<256
            if z>totalPathDistance
                z = z - totalPathDistance
            z = z + 0.2

            val curve = gameMap[section].curvature

            if z<gameMap[section].endPos
                # Increment fits in this section
                x = x + dx*0.2 + 0.5 * curve * 0.04
                dx = dx + curve * 0.2
            else
                # Increment crosses into next section
                val t = (gameMap[section].endPos - (z - 0.2)) # fraction of increment in this section
                x = x + dx * t + 0.5 * curve * t * t
                dx = dx + curve * t
                section = if section<gameMap.length-1 then section + 1 else 0
                val remainingT = 0.2 - t
                val nextCurve = gameMap[section].curvature
                x = x + dx * remainingT + 0.5 * nextCurve * remainingT * remainingT
                dx = dx + nextCurve * remainingT

            # Interpolate slope at this Z
            val t = (z - (z as Int) as Float)
            val index1 = (z as Int) % slopeMap.length
            val slope1 = slopeMap[index1]
            val index2 = (index1 + 1) % slopeMap.length
            val slope2 = slopeMap[index2]
            val slope = slope1*(1.0 - t) + (slope2* t)
            y = y + (slope - cameraTilt) * 0.2

            # Adjust camera tilt
            if i=0 
                cameraTilt = cameraTilt * 0.9 + slope * 0.1

            
            roadX[i] = x
            roadY[i] = y
            roadWidth[i] = getPathWidth(z)

    fun interpolateRoadCoords(z:Float) -> (Float, Float)
        # interpolate road coordinates at arbitrary Z
        val index = (z / 0.2) as Int
        if index>=255
            return (roadX[255], roadY[255])
        val t = (z - (index as Float)*0.2) / 0.2
        val x = roadX[index] + t * (roadX[index+1] - roadX[index])
        val y = roadY[index] + t * (roadY[index+1] - roadY[index])
        return (x, y)

    fun drawRoad()
        #kprintf("\n\nDrawing road at distanceIntoSegment %f map index %d\n", distanceIntoSegment, currentMapIndex)
        # walk along the road in Z
        horizonRow = SCREEN_HEIGHT        # Check that we haven't occluded everything
        # var objectIndex = 0

        var prevScreenY = SCREEN_HEIGHT
        var prevRoadCenterX = 320.0
        var prevRoadWidth = 640.0
        var prevScale = 1.0
        gc.setTransparentColor(-1)  # no transparency for road drawing

        # kprintf("Drawing road width=%f:\n", roadWidth[0])
        
        # coordinates along the road
        for z in 0..<=255
            # project road segment at distance z onto screen
            val scale = focalLength / (0.2*z+ cameraZ)
            val thisScreenY = (screenCenterY - (roadY[z]-cameraY)*scale) as Int
            val thisRoadCenter = roadX[z]
            val thisRoadWidth = roadWidth[z]

            if z=0
                prevScreenY = thisScreenY
                prevRoadCenterX = thisRoadCenter
                prevRoadWidth = thisRoadWidth
                prevScale = scale

            # only draw if we are on screen and haven't already drawn something closer
            occlusionY[z] = horizonRow
            if thisScreenY<horizonRow 
                # Interpolate from last row to this row
                val numRows = prevScreenY - thisScreenY
                #kprintf("Interpolating %d rows from %d to %d\n", numRows, prevScreenY, thisScreenY)
                for iy in 1..<=numRows
                    #kprintf("  Drawing row %d of %d\n", iy, numRows)
                    val interpY = prevScreenY - iy
                    if interpY<0 or interpY>480
                        continue
                    val t = (iy as Float) / (numRows as Float)
                    val interpCenter = prevRoadCenterX + t * (thisRoadCenter - prevRoadCenterX)
                    val interpWidth = prevRoadWidth + t * (thisRoadWidth - prevRoadWidth)
                    val interpScale = prevScale + t * (scale - prevScale)
                    val dist = carZ + 0.2 *z + t * 0.2
                    val stripePhase = ((dist / stripeLength) as Int)
                    drawRoadScanLine(interpCenter, interpY, interpWidth, interpScale, stripePhase)

                horizonRow = thisScreenY
            end if
            prevRoadCenterX = thisRoadCenter
            prevRoadWidth = thisRoadWidth
            prevScreenY = thisScreenY
            prevScale = scale
            # kprintf("Projected road z=%d to screenY=%d center=%f width=%f\n", z, thisScreenY, thisRoadCenter, thisRoadWidth)
        end for
        gc.drawRect(0, 0, SCREEN_WIDTH, horizonRow, 0)  # sky

        gc.setTransparentColor(0)  # enable transparency after road drawing
        for bg in 0..1
            val image = backgroundImage[2*level+bg]
            var bgHorizontRow = (screenCenterY + cameraTilt*50) as Int
            if bgHorizontRow<horizonRow
                bgHorizontRow = horizonRow
            val bgTop = bgHorizontRow - image.height + 2*bg
            val visible = if bgHorizontRow>horizonRow then horizonRow - bgTop else image.height
            if visible>0
                val offsetInt = backgroundOffset[bg] as Int
                if offsetInt+640>=image.width
                    val overlap =  image.width - offsetInt
                    gc.drawImage(0, bgTop, overlap, visible, offsetInt,0,  image)
                    gc.drawImage(overlap, bgTop, 640 - overlap, visible, 0,0,  image)
                else
                    gc.drawImage(0, bgTop, 640, visible, offsetInt,0,  image) 
    end fun

    fun calcRoadEdges (x:Float, width:Float) -> (Float, Float)
        const laneWidth = 5.0
        var leftEdgeWorldX = x - 2.2 * laneWidth
        if width>5.5
            leftEdgeWorldX = leftEdgeWorldX + (width - 5.6) * laneWidth
        
        val rightEdgeWorldX = leftEdgeWorldX + width*laneWidth
        return (leftEdgeWorldX, rightEdgeWorldX)


    fun drawRoadScanLine(x:Float, y:Int, width:Float, scale:Float, stripePhase:Int)
        # draw a single scan line of the road
        # The road coordinates correspond to the center of a 3 lane road. Additional lanes are on the right.
        # Then the right edge is left edge + width
        val (leftEdgeWorldX, rightEdgeWorldX) = calcRoadEdges(x, width)

        # convert to screen coordinates
        val startX = (screenCenterX + leftEdgeWorldX * scale) as Int
        val endX = (screenCenterX + rightEdgeWorldX * scale) as Int

        # add entry to copper list for road color at this scanline
        val groundPallette = 8*level_palette[3*level]
        val groundColorIndex = groundPalettes[groundPallette + ((stripePhase lsr 1)&7)]   # road palette index
        copperList.set(y*3+1, groundColorIndex)

        # kprintf("  Road scanline at y=%d center=%f startX=%d endX=%d width=%f scale=%f\n", y, x, startX, endX, width, scale)

        if startX>=SCREEN_WIDTH or endX<=0
            gc.drawRect(0, y, SCREEN_WIDTH, y+1, 0x00) # all grass
            return
        elsif (startX<0 and endX>SCREEN_WIDTH) # all road
            gc.drawRect(0, y, SCREEN_WIDTH, y+1, 0x24)
        else 
            val startXClipped = if startX<0 then 0 else startX
            val endXClipped = if endX>SCREEN_WIDTH then SCREEN_WIDTH else endX
            gc.drawRect(0, y, startXClipped, y+1, 0x00)
            gc.drawRect(startXClipped, y, endXClipped, y+1, 0x24) # road
            gc.drawRect(endXClipped, y, SCREEN_WIDTH, y+1, 0x00)
        
        const laneWidth = 5.0
        val laneWidthPixels = (laneWidth * scale) as Int

        if width > 6.0
            # draw central divider
            val divStart = startX + 3 * laneWidthPixels
            val divEnd = endX - 3 * laneWidthPixels
            gc.drawRect(divStart, y, divEnd, y+1, 0x0)


        # draw road stripes
        val lineWidth = (0.3 * scale) as Int
        if lineWidth<1
            return

        val num_lanes = width as Int
        val lanesOnLeft = if num_lanes>6 then 3 else (num_lanes+1) / 2
        val lanesOnRight = if num_lanes>6 then 3 else (num_lanes+1) - lanesOnLeft

        # draw lane markings
        if (stripePhase&2)=0
            for laneIndex in 1..<lanesOnLeft
                val laneX = startX + laneIndex * laneWidthPixels
                gc.drawRect(laneX, y, laneX + lineWidth, y+1, 0x38)
            for laneIndex in 1..<lanesOnRight
                val laneX = endX - laneIndex * laneWidthPixels
                gc.drawRect(laneX, y, laneX + lineWidth, y+1, 0x39)
        # draw curbs
        val curbColor = if (stripePhase&1)=0 then 0x5F else 0x3F
        gc.drawRect(startX-lineWidth, y, startX + lineWidth, y+1, curbColor)
        gc.drawRect(endX-lineWidth, y, endX+lineWidth, y+1, curbColor)
        if (num_lanes>6)
            # draw outer curbs
            val x1 = startX + 3 * laneWidthPixels
            gc.drawRect(x1- lineWidth, y, x1, y+1, curbColor)
            val x2 = endX - 3 * laneWidthPixels
            gc.drawRect(x2-lineWidth, y, x2, y+1, curbColor)        

    fun drawScenery()
        # scan through scenery list back to front
        hwregs.ledr = 0
        gc.setTransparentColor(0)
        for index in scenery.length-1..>=0
            val distance = scenery[index].pos - carZ
            val props = (scenery[index].props lsr 4) as SpriteProperties
            val mirrored = (scenery[index].props&1)!=0

            if distance<0.0 or distance>50.0
                continue  # object is behind us or too far ahead    

            val (roadX, roadY) = interpolateRoadCoords(distance)
            val scale = focalLength / (distance + cameraZ)
            val screenY = (screenCenterY - (roadY + scenery[index].y/20.0 - cameraY) * scale) as Int
            # kprintf("Drawing scenery index %d %f %f scale=%f screenY=%d props=%d\n", index, scenery[index].y, cameraY, scale, screenY,props)
            val spriteX = scenery[index].x + roadX

            val screenX = (screenCenterX + spriteX * scale) as Int
            # kprintf("Scenery object %d type=%d at x=%f z=%f distance=%f scale=%f screenX=%d screenY=%d\n", index, scenery[index].type, scenery[index].x, scenery[index].pos, distance, scale, screenX, screenY)

             # Check for collision with car
            val sprite = sprites[SPRITE_SCENERY + scenery[index].type]
            val scalex = scale * 0.11 # convert from world scale to sprite scale
            val spriteWidth = (sprite.width * scalex) as Int
            val spriteHeight = (sprite.height * scalex) as Int
            var drawX = screenX - (spriteWidth / 2)
            if props.alignEdgeX
                drawX -= if mirrored then spriteWidth/2 else -spriteWidth/2

            var drawL = drawX
            var drawR = drawX + spriteWidth
            var type = scenery[index].type

            # Special case for certain trees - make collision box smaller 
            if type=33
                if mirrored
                    drawR -= spriteWidth/2
                else
                    drawL += spriteWidth/2

            if distance<(0.5+0.01*speed) and drawL<320 and drawR>320 and scenery[index].y<50.0 and not props.noCollision
                kprintf("Collision with scenery object %d type=%d at X=%d-%d props=%d\n", index, scenery[index].type, drawX,drawX+spriteWidth, props)

                if flipState=0
                    if speed>120.0
                        audio.crash.play()
                        flipState = 2  # start flip
                    elsif speed>40.0
                        audio.smallCrash.play()
                        flipState = 1  # start spin
                    flipCounter = 0


            if drawX+spriteWidth<0 or drawX>=SCREEN_WIDTH
                continue  # sprite is off left or right of screen
            var drawY = if props.alignCenterY then screenY - spriteHeight/2 else screenY - spriteHeight
            if props.alignBottom
                drawY -= 3*spriteHeight
            if drawY+spriteHeight<0 or drawY>=SCREEN_HEIGHT
                continue  # sprite is off top or bottom of screen

            # Check for occlusion
            val occlusionRow = occlusionY[(distance / 0.2) as Int]
            # kprintf(" Scenery object %d at distance %f projected to screenY=%d occlusionY=%d\n", index, distance, drawY, occlusionRow)
            val maxDrawHeight = occlusionRow - drawY
            if maxDrawHeight<0
                continue  # totally occluded

            # Center alinged sprites (such as water) need special handling for occlusion. 
            # These represent horizontal surfaces at ground level, not vertical objects like trees.
            # If the center of such a sprite is visible then we can treat it as if the whole sprite is visible - even if
            # a normal occlusion test would cull it.
            val adjMaxDraw = if props.alignCenterY and maxDrawHeight>spriteHeight/2 then spriteHeight else maxDrawHeight
            if scenery[index].props=49
                gc.drawRect(0, drawY, drawX, drawY + (sprite.height*scalex) as Int, 0xFC) # water color

            val mirrorX = if mirrored then -1.0 else 1.0
            if scale<60.0 and scale>-60.0
                gc.drawImage(drawX, drawY, adjMaxDraw, sprite, scalex*mirrorX, scalex)
                if props.extraWide
                    gc.drawImage(drawX+spriteWidth, drawY, adjMaxDraw, sprite, scalex*mirrorX, scalex)
                    gc.drawImage(drawX-spriteWidth, drawY, adjMaxDraw, sprite, scalex*mirrorX, scalex)
                # kprintf(" %d scale=%f\n", index, scalex)

    fun drawNpcVehicles()
        rank = 1
        for vehicle in npcVehicles
            if  vehicle.laps>laps or (vehicle.laps=laps and vehicle.z>carZ)
                rank += 1

            val distance = vehicle.z - carZ
            if distance<0.0 or distance>50.0
                continue  # object is behind us or too far ahead    

            val (roadX, roadY) = interpolateRoadCoords(distance)

            val scale = focalLength / (distance + cameraZ)
            val screenY = (screenCenterY - (roadY - cameraY) * scale) as Int
            val spriteX = vehicle.x + roadX
            # kprintf("Drawing NPC vehicle at x=%f z=%f distance=%f scale=%f screenY=%d\n", vehicle.x, vehicle.z, distance, scale, screenY)

            val screenX = (screenCenterX + spriteX * scale) as Int
            val sprite = sprites[vehicle.spriteIndex]
            val scalex = scale * 0.08 # convert from world scale to sprite scale
            val spriteWidth = (sprite.width * scalex) as Int
            val spriteHeight = (sprite.height * scalex) as Int
            val drawX = screenX - (spriteWidth / 2)

            # After a collision with a car, skip collision detection for a few frames - to avoid multiple collisions
            if vehicle.collisionCounter>0
                vehicle.collisionCounter = vehicle.collisionCounter - 1

            if distance>0.25 and distance<0.75 and drawX<320 and drawX+spriteWidth>320 and vehicle.collisionCounter=0
                if vehicle.speed>speed
                    # The NPC is overtaking us - move the NPC car to one side to avoid collision
                    kprintf("NPC vehicle overtaking at distance %f speed %f npc speed %f\n", distance, speed, vehicle.speed)
                    if carX>0.0
                        vehicle.x = vehicle.x - 5.0
                    else
                        vehicle.x = vehicle.x + 5.0
                    audio.beep2.play()
                else
                    # We have hit the NPC car
                    kprintf("Collision with NPC vehicle at distance %f speed %f npc speed %f\n", distance, speed, vehicle.speed)
                    speed = vehicle.speed - 10
                    vehicle.collisionCounter = 30  # skip collision detection for next 30 frames
                    if flipState=0
                        flipState = 1  # start spin
                        audio.pops.play()

            if drawX+spriteWidth<0 or drawX>=SCREEN_WIDTH
                continue  # sprite is off left or right of screen
            val drawY = screenY - spriteHeight
            if drawY+spriteHeight<0 or drawY>=SCREEN_HEIGHT
                continue  # sprite is off top or bottom of screen

            # Check for occlusion
            val occlusionRow = occlusionY[(distance / 0.2) as Int]
            # kprintf(" Scenery object %d at distance %f projected to screenY=%d occlusionY=%d\n", index, distance, drawY, occlusionRow)
            val maxDrawHeight = occlusionRow - drawY
            if maxDrawHeight<0
                continue  # totally occluded


            if scale<120.0
                gc.drawImage(drawX, drawY, maxDrawHeight, sprite, scalex, scalex)

        val speedStr = atos(rank)
        gc.drawText(10, 10, 1, "Position ") 
        gc.drawText(90, 10, 1, speedStr)
        free speedStr


    fun drawFrame()
        # lastRow now contains the screen coordinate of the horizonRow
        gc.setTransparentColor(0)  # enable transparency
        # add speedometer
        val speedStr = atos(speed as Int)
        gc.drawText(280, 10, 1, "Speed ")
        gc.drawText(340, 10, 1, speedStr)
        free speedStr

        val distStr = atos(carZ as Int)
        gc.drawText(280, 30, 1, "Dist ")
        gc.drawText(340, 30, 1,  distStr)
        free distStr

        # draw the car sprite
        val sprite : Image
        if flipState=1
            sprite = sprites[SPRITE_CAR_SPIN1 + (flipCounter /24) %4]
            flipCounter = flipCounter + 1
            if flipCounter>=64
                flipState = 0
                flipCounter = 0

        elsif flipState=2
            sprite = sprites[SPRITE_CAR_FLIP1 + (flipCounter /32) %7]
            flipCounter = flipCounter + 1
            if flipCounter>=224
                flipState = 0
                flipCounter = 0

        elsif cameraTilt > 0.02
            if carTurning>10 or carTurning<-10
                sprite = sprites[SPRITE_CAR_UPTURN]
            else
                sprite = sprites[SPRITE_CAR_UP]
        elsif cameraTilt < -0.02
            if carTurning>10 or carTurning<-10
                sprite = sprites[SPRITE_CAR_DOWNTURN]
            else
                sprite = sprites[SPRITE_CAR_DOWN]
        else
            if carTurning>10 or carTurning<-10
                sprite = sprites[SPRITE_CAR_TURN2]
            else if carTurning!=0
                sprite = sprites[SPRITE_CAR_TURN]
            else
                sprite = sprites[SPRITE_CAR_STRAIGHT]

        val carY = if flipState=2 then 280 else 370
        if carTurning<0
            gc.drawImage(320-88,carY,sprite,2.0,2.0)
        else
            gc.drawImage(320-88,carY,sprite, -2.0, 2.0)

        if (leftWheelOffRoad or rightWheelOffRoad) and speed>20.0
            smokeCounter = smokeCounter + 1
            if smokeCounter>=12
                smokeCounter = 0
            if leftWheelOffRoad
                gc.drawImage(248,432,sprites[SPRITE_SMOKE4-smokeCounter/3],1.0,1.0) # left side
            if rightWheelOffRoad
                gc.drawImage(362,432,sprites[SPRITE_SMOKE4-smokeCounter/3],-1.0,1.0) # right side
        else
            smokeCounter = 0
    end fun

    fun displaySprites()
        var index = 1
        gc.setTransparentColor(-1)  # Set transparency color to palette index 0
        while(true)
            gc.drawRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0)  # black background
            val sprite = sprites[index+SPRITE_SCENERY-1]
            val scale = 1.0
            val spriteWidth = (sprite.width * scale) as Int
            val spriteHeight = (sprite.height * scale) as Int
            val drawX = 50
            val drawY = 50
            gc.drawImage(drawX, drawY, sprite, scale, scale)

            val indexStr = atos(index)
            gc.drawText(10, 10, 0, 10, "Sprite index ")
            gc.drawText(116, 10, 0, 10, indexStr)   
            free indexStr

            var key = 0
            while key=0
                key = kb.getKey() as Int

            if key=KEY_UP
                index = index + 1
                if index>=sprites.length
                    index = 1
            elsif key=KEY_DOWN
                index = index - 1   

    fun moveNpcVehicles()
        for npc in npcVehicles
            npc.move()

    fun gameOver()
        val finalStr : String
        if level=16 and rank<=10
            finalStr = "Well done! You finished the game with score "
        else
            finalStr = "Game Over! Your final score is "
        gc.drawText(100, 200, 20, finalStr)
        val scoreStr = atos(score)
        gc.drawText(400, 200, 20, scoreStr) 
        gc.drawText(200, 240, 20, "Press 'N' to start again")
        gc.setTransparentColor(0)  # Enable transparency
        hwregsAudio[1].volume = 0


        while true
            val key = kb.getKey()
            if key='m'
                score = 0
                selectLevel(0)
    end fun

    fun rankToScore(rank:Int) -> Int
        when rank
            1 ->  return 20
            2 ->  return 15
            3 ->  return 12
            4 ->  return 10
            5 ->  return 7
            6 ->  return 5
            7 ->  return 4
            8 ->  return 3
            9 ->  return 2
            10 -> return 1
            else -> return 0

    fun selectLevel(levelIndex:Int)
        gc.setGraphicsBuffer(screenBuffer1)
        hwregsVideo.addr = screenBuffer1
        gc.setTransparentColor(-1)  # Disable transparency
        gc.drawRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0)  # black background
        
        if level=16 or rank>10
            gameOver()

        level = levelIndex
        scenery = allScenery[levelIndex]
        slopeMap = allSlopeMap[levelIndex]
        gameMap = allGameMap[levelIndex]
        widthMap = allWidthMap[levelIndex]

        val levelStr = atos(levelIndex+1)
        gc.drawText(200, 200, 20, "Get ready for level ")
        gc.drawText(400, 200, 20, levelStr)
        free levelStr

        if level!=0
            gc.drawText(200, 160, 20, "You finished in position ")
            val rankStr = atos(rank)
            gc.drawText(450, 160, 20, rankStr)
            free rankStr
            score += rankToScore(rank)
            gc.drawText(200, 180, 20, "Total score: ")
            val scoreStr = atos(score)
            gc.drawText(320, 180, 20, scoreStr)
            free scoreStr


        gc.drawText(200, 240, 20, levelNames[levelIndex])
        gc.drawText(200, 280, 20, "Press 'S' to start")
        gc.setTransparentColor(0)  # Enable transparency
        hwregsAudio[1].volume = 0

        # Set the copperlist to all black
        val paletteRegs = unsafe(0xE0001000 as Pointer<Int>)

        var x = -5.0
        var dx = 0.2
        for i in 0..<npcVehicles.length
            val v = npcVehicles.get(i)
            dx = -dx
            x = x + 5.0
            if x>=18.0
                x = -5.0
            v.speed = 0.0
            v.x = x
            v.z = 3.0*(19-i)
            v.dx = dx
            v.laps = 0

        speed = 0.0
        carX = 0.0
        carZ = 0.0
        carTurning = 0
        currentCurveIndex = 0
        laps = 0
        startTimer = 200 

        while true
            paletteRegs[0] = 0x00000000
            val key = kb.getKey()
            if key='s'
                break

        


    fun gameLoop()
        # Wait for vertical blank
        # hwregs.seven_seg = hwregs.vga_pos
        while hwregs.vga_pos > 480
            delay()
        while hwregs.vga_pos < 480
            delay()
        
        if startTimer>0
            startTimer = startTimer - 1

        if doubleBufferPhase=0
            gc.setGraphicsBuffer(screenBuffer1)
            hwregsVideo.addr = screenBuffer2
            doubleBufferPhase = 1
        else
            gc.setGraphicsBuffer(screenBuffer2)
            hwregsVideo.addr = screenBuffer1
            doubleBufferPhase = 0
        gc.setTransparentColor(0)  # Set transparency color to palette index 0
        hwregs.copper_pc = unsafe(copperList.array as Int)

        val frameNumber = hwregs.frame_number
        val t1 = hwregs.vga_pos
        updateCarPosition()
        moveNpcVehicles()
        val t2 = hwregs.vga_pos
        calcRoadCoords()
        val t3 = hwregs.vga_pos
        drawRoad()
        val t4 = hwregs.vga_pos
        drawFrame()
        drawScenery()
        drawNpcVehicles()
        setCopperList(copperList, cameraTilt)
        val t5 = hwregs.vga_pos
        # kprintf("Frame %d: start=%d calcRoad=%d drawRoad=%d drawFrame=%d end=%d\n", frameNumber, t1, t2, t3, t4, t5)
        hwregs.seven_seg = hwregs.vga_pos
        #abort(1)  # Temporary to stop after one frame



fun drawPallette(gc:GraphicsContext)
    gc.drawRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0)  # black background
    for i in 0..<=255
        val x = (i % 16) * 40
        val y = (i / 16) * 30
        gc.drawRect(x, y, x+38, y+28, i)
    abort(0)

class AudioSample(val addr: Int,val length: Int)
    fun play()
        # Play the audio sample using the audio hardware
        hwregsAudio[0].addr       = addr
        hwregsAudio[0].volume     = (64 lsl 16) | 64  # Left and right volume
        hwregsAudio[0].pitch      = 0x3000            # Playback frequency
        hwregsAudio[0].rep_addr   = 0
        hwregsAudio[0].rep_length = 0
        hwregsAudio[0].length = length               # Writing to length starts playback

fun makeAudioSample(audioData: Array<Char>, offset: Int, length: Int) -> AudioSample
    return new AudioSample(unsafe(audioData as Int)+ offset, length)

class AudioSamples(data: Array<Char>)
    val getReady = makeAudioSample(data, 0x00000058, 0x000014D4)
    val checkpoint = makeAudioSample(data, 0x00001584, 0x00001AF4)
    val applause = makeAudioSample(data, 0x00003078, 0x00004690)
    val applause2 = makeAudioSample(data, 0x00007708, 0x00004950)
    val squeel = makeAudioSample(data, 0x0000C058, 0x00000840)
    val crash = makeAudioSample(data, 0x0000C9F8, 0x00004098)
    val pops = makeAudioSample(data, 0x00010BF0, 0x00003EB4)
    val smallCrash = makeAudioSample(data, 0x00014BAC, 0x000037FC)
    val beep2 = makeAudioSample(data, 0x000183A8, 0x00000578)
    val congratulations = makeAudioSample(data, 0x00018978, 0x00002E90)
    val wave = makeAudioSample(data, 0x0001BE92, 0x0000C934)
    val beeps = makeAudioSample(data, 0x000287C6, 0x00001FC0)
    val ping = makeAudioSample(data, 0x0002A786, 0x0000164C)
    val bong = makeAudioSample(data, 0x0002BDD2, 0x000042E4)
    val beepBeepBeep = makeAudioSample(data, 0x000300B6, 0x00003608)

fun delay()
    val leds = hwregs.ledr 
    hwregs.ledr = leds | 4
    for i in 0..<=10000
        val dummy=1
    hwregs.ledr = leds

fun main()
    copyFontData()
    val gc = new GraphicsContext()
    gc.setup()
    gc.setTransparentColor(0)  # Set transparency color to palette index 0
    
    val kb = new Keyboard()


    val pcmData = readFile("../../../Downloads/outrun_amiga_edition_v092/audio/pcm.bin")
    if pcmData is Error
        kprintf("Error loading audio file\n")
        abort(1)
    val audioSamples = new AudioSamples(pcmData)

    val enginePcmData = readFile("../../../Downloads/outrun_amiga_edition_v092/audio/pcm_engine.bin")
    if enginePcmData is Error
        kprintf("Error loading engine audio file\n")
        abort(1)

    game = new Game(gc, kb, audioSamples)

    game.sprites = loadSprites()
    game.backgroundImage = loadBackgroundImage()

    game.loadGameMap("level_path.bin")

    game.copperList = createCopperList()
    kprintf("Copper list created at %x with %d entries\n", game.copperList,  game.copperList.length)

    val paletteRegs = unsafe(0xE0001000 as Pointer<Int>)
    for i in 0..<=255
        paletteRegs[i] = palette[i]
    # drawPallette(gc)

    var dx = 0.025
    var x = -5.0
    for i in 19..>=1
        game.npcVehicles.add(new NpcVehicle(x, 2.0*i, SPRITE_NPC_CAR1-1+i, 110.0+i*2.0, dx))
        dx = -dx
        x = x + 5.0
        if x>=18.0
            x = -5.0

    # game.displaySprites()
    hwregsAudio[1].addr = unsafe(enginePcmData as Int) + 0x6208
    hwregsAudio[1].rep_addr = unsafe(enginePcmData as Int) + 0x6208
    hwregsAudio[1].volume = (48 lsl 16) | 48  # Left and right volume
    hwregsAudio[1].pitch = 0x3000            # Playback frequency
    hwregsAudio[1].rep_length = 0x08f0  # Set repeat length for looping
    hwregsAudio[1].length = 0x008f0  # Set length to start playback

    game.selectLevel(0)
    hwregsAudio[1].volume = 0
    game.audio.getReady.play()


    while true
        game.gameLoop()
    

